#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{color,listings} %bindet das Paket Listings ein

% Der lstset-Befehl ermöglicht haufenweise Einstellungen zur Formatierung
\lstset{language=html,
captionpos=b, % Beschriftung ist unterhalb
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
basicstyle=\ttfamily, % Schriftart
keywordstyle=\color{blue}, % Farbe für die Keywords wie public, void, object u.s.w.
commentstyle=\color{green}, % Farbe der Kommentare
stringstyle=\color{red}, % Farbe der Zeichenketten
numbers=left, % Zeilennummern links vom Code
numberstyle=\tiny, % kleine Zeilennummern
numbersep=5pt,
breaklines=true, % Wordwrap a.k.a. Zeilenumbruch aktiviert
showstringspaces=false,
% emph legt Farben für bestimmte Wörter manuell fest
emph={double,bool,int,unsigned,char,true,false,void},
emphstyle=\color{blue},
emph={Assert,Test},
emphstyle=\color{red},
emph={[2]\using,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}
}




\usepackage{anysize}
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Entwicklung eines graphischen Editors zur Modellierung von Systemen mit dynamischer Modellstruktur"
\pdf_author "Andreas Bachmann, Andreas Butti"
\pdf_subject "(AB)² Simulation"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subject{Bachelorthesis Frühlingssemester 2012}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Entwicklung eines graphischen Editors zur Modellierung von Systemen mit
 dynamischer Modellstruktur
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

Andreas Bachmann
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
small{
\backslash
tt{bachman0@students.zhaw.ch}}
\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Andreas Butti 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
small{
\backslash
tt{buttiand@students.zhaw.ch}}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
publishers{
\end_layout

\begin_layout Plain Layout

	
\backslash
vspace{6cm}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{minipage}[t]{7cm}
\end_layout

\begin_layout Plain Layout

		{
\backslash
small Betreuer:}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
large Prof.
 Dr.
 Stephan Scheidegger
\backslash

\backslash
{
\backslash
normalsize School of Engineering
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		Technikumstrasse 9
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		8400 Winterthur 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		Telefon: 058 934 74 63
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		{
\backslash
tt{stephan.scheidegger@zhaw.ch}}} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{minipage}[t]{6cm}
\end_layout

\begin_layout Plain Layout

		{
\backslash
small Betreuer:}
\backslash

\backslash

\backslash
large Dr.
 Rudolf Marcel Füchslin
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		{
\backslash
normalsize School of Engineering
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		Technikumstrasse 9
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		8400 Winterthur 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		Telefon: 058 934 75 92
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		{
\backslash
tt{rudolf.fuechslin@zhaw.ch}}}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
Englische Version von “Zusammenfassung”
\end_layout

\begin_layout Section*
Zusammenfassung
\end_layout

\begin_layout Standard
Wird erst am Ende der Arbeit geschrieben
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Vorwort
\end_layout

\begin_layout Standard

\color red
(= persönliches)
\end_layout

\begin_layout Standard
In der Forschung aber auch zu Unterrichtszwecken werden viele Theorien vermittel
t und Simuliert.
 Solche Simulationen basieren meistens auf einem strikt mathematischen Hintergru
nd, meinst Integrale erster Ordnung.
 Forschende Personen im Bereich Physik / Biologie verwenden dabei bevorzugt
 eine Modellierungssoftware, da es nicht ihr Fachgebiet ist selbst zu programmie
ren.
 Andreas Butti hat sich bei der Verwendung von Simulationstools über deren
 Plattformabhängigkeit und Benutzerunfreundlichkeit gestört.
 Als Informatiker kommt man da schnell in Versuchung selbst etwas besserer
 zu schreiben.
 Nach einem Gespräch mit dem Physikdozenten, Herr Scheidegger, wurde daraus
 dann diese BA, die jedoch nicht nur ein Benutzerfreundliches Simulationswertzeu
g sein soll, sondern auch bisher nicht vorhandene Möglichkeiten für die
 Simulationen von Biologischen Abläufen, wie das innere einer Zelle, darstellen
 soll.
 TODO: Danksagung
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard

\color red
fusion->trennen von Meso (nicht implementiert)
\end_layout

\begin_layout Standard

\color red
FSM->nicht invivo
\end_layout

\begin_layout Standard
Es gibt bereits viele Simulationstools, wie z.B.
 Berekely Madonna um nur ein bekanntes Beispiel zu nennen.
 Diese Tools unterstützten die Modelierung von Differentialgleichungen als
 Modell, mit Containern und Flüssen.
\end_layout

\begin_layout Standard
Das gleiche Prinzip wird auch von Symlink verwendet, dieses verwendet als
 Symbole jedoch konsequent die Elektrotechnischen Abbildungen, es gibt Verbindun
g, Verstärker, Verzögerungen (x[t-1]) etc.
 Obwohl das Modell damit etwas anders aussieht ist die mathematische Abbildung
 schlussendlich die gleiche.
\end_layout

\begin_layout Standard
Da unsere Simulation keine Elektrotechnischen Hintergrund hat haben wir
 für die Darstellungen unserer Flussmodelle ebenfalls Container mit Flüssen
 (Integral) verwendet.
\end_layout

\begin_layout Subsection
Bereits existierende Tools
\end_layout

\begin_layout Subsection
Vorgabe
\end_layout

\begin_layout Standard
Bestehende graphische Modelleditoren erlauben eine effiziente Modellierung
 von kompartimentalen Systemen.
 Dabei unterstützt die graphische Oberfläche die Strukturierung des Modells
 bzw.
 des Systems.
 Dies kann gerade bei der Erfassung von komplexen Systemen den Zugang zu
 einer adäquaten Systembeschreibung erleichtern.
 Gerade aber Modelleditoren wie Berkeley-Madonna sind auf eine kompartimentale
 Struktur des Systems angewiesen.
 Räumlich strukturierte bzw.
 verteilte Systeme lassen sich nur schwer und in vereinfachter Form abbilden.
 Die Verwendung oder Kopplung verschiedener Simulationswerkzeuge kann für
 gewisse technische Systeme in Betracht gezogen werden (z.B.
 elektrische Schaltung mit Komponenten, bei denen die Wärmeabstrahlung und
 oder Wärmeleitung räumlich modelliert werden).
 Bei vielen Systemen lässt sich aber durch eine solche Kopplung das System
 nicht abbilden.
 Bei biologischen Systemen z.B.
 können sich Kompartimente bewegen (bei Zellen z.B.
 Chemo- und Haptotaxis).
 Zudem zeichnen sich biologische Systeme durch hierarchische Kompartimentstruktu
ren mit Unterkompartimenten aus.
 Ein weiterer Aspekt betrifft die Möglichkeit, dass Kompartimente in biologische
n Systemen fusionieren oder sich teilen können.
 Anforderungen Das zu entwickelnde Modellierungswerkzeug soll an die intuitive
 graphische Oberfläche bestehender Modellierungswerkzeuge für kompartimentale
 Simulationen anknüpfen.
 Folgene Aspekte sollen konzeptuell untersucht und wenn möglich implemetiert
 werden: - Hierarchische Kompartimente
\end_layout

\begin_layout Standard
Hierarchische Kompartimente - Räumliche Positionierung von Kompartimenten,
 welche die Wechselwirkung der Kompartimente auf gleicher Stufe beeinflussen
 kann und somit Einführung von Koordinaten (erster Schritt 2-Dim.) bzw.
 orthogonales Grid und beschreibung von Gradienten (z.B.
 für Änderung der räumlichen Position von Kompartimenten aufgrund von z.B.
 Gradienten) - Ausgabe eines Codes in einer Markup language (z.B.
 SBML), welcher von einem bestehenden Solver ausgeführt werden kann (z.B.
 Matlab)
\end_layout

\begin_layout Subsection
Problemstellung (oder Motivation)
\end_layout

\begin_layout Standard

\color red
Motivation durch Problemstellung!
\end_layout

\begin_layout Standard

\color red
signalig chains (SimuLink), Biologie.
 Motivation->Problem->Insiliko
\end_layout

\begin_layout Standard
Mit unserer Simulation ist es zusätzlich möglich in einem XY Modell mehrere
 Meso Kompartmente abzubilden, ein Meso Kompartment ist das vorhin genannte
 Flussmodel.
 Diese Meso Kompartmente können sich wären der Simulation im XY-Raum bewegen.
 Es können Dichten angegeben werden, die über den XY Raum verteilt sind,
 und die Meso Kompartmente können an Ihrer aktuellen Position von der dichte
 Konsumieren oder dichte Produzieren, somit kann die Umgebung beeinflusst
 werden.
 Mit diesen Fähigkeiten ist es möglich das innenleben einer Zelle oder andere
 Biologische Prozesse einfach, grafisch abzubilden.
 Die Idee und Vorgabe dieser Simulationsmethode stammt von Herr Scheidegger,
 und wurde zusammen mit Herr Füchslin und uns ausgearbeitet.
\end_layout

\begin_layout Section
Theoretische Grundlagen
\end_layout

\begin_layout Standard

\color red
partielle differentialgleichung->wann?
\end_layout

\begin_layout Standard

\color red
analytisch->nur linear
\end_layout

\begin_layout Subsection
Numerische Lösungsverfahren
\end_layout

\begin_layout Standard
Eine Gewöhnliche Differentialgleichung (engl.
 Ordinary Differential Equation ODE) ist eine mathematische Gleichung, die
 Ableitungen, die Funktion selbst sowie die unabhängige Variable enthalten
 kann.
 Ableitungen und die Funktion selbst treten nach genau einer unabhängigen
 Variable auf.
 Lösung 
\begin_inset Formula $y\left(t\right)$
\end_inset

 einer Differentialgleichung 
\begin_inset Formula $y^{\left(n\right)}$
\end_inset

ist eine Funktion, die mit ihren Ableitungen deckungsgleich mit der Differential
gleichung selbst ist.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y^{\left(n\right)}=f\left(t,\; y\left(t\right),\; y^{\prime}\left(t\right),\;\ldots,\; y^{\left(n-1\right)}\left(t\right)\right)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Auf analytischem Weg kann eine Differentialgleichung durch Integration erfolgen.
 Die Fallbeschleinigung in Abbildung soll in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:fallbesch"

\end_inset

 als Beispiel gezeigt werden.
 Wir kennen die Beschleunigungs-Funktion 
\begin_inset Formula $a\left(t\right)$
\end_inset

, suchen die Weg-Funktion 
\begin_inset Formula $s\left(t\right)$
\end_inset

, finden durch Integration eine Lösung und kommen durch abermaliges Differenzier
en wieder auf die Ursprüngliche Beschleunigungs-Funktion zurück.
\end_layout

\begin_layout Standard

\color red
schlechtes Beispiel
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
a\left(t\right) & = & \ddot{s}\left(t\right)=-g\label{eq:fallbesch}\\
v\left(t\right) & = & \int a\left(t\right)\cdot dt=\int-g\cdot dt=-gt+v\left(0\right)\nonumber \\
s\left(t\right) & = & \int v\left(t\right)\cdot dt=\int\left(-gt+v\left(0\right)\right)\cdot dt=-\frac{1}{2}gt^{2}+v\left(0\right)t+s\left(0\right)\nonumber \\
v\left(t\right) & = & \frac{d}{dt}\left[-\frac{1}{2}gt^{2}+v\left(0\right)t+s\left(0\right)\right]=-gt+v\left(0\right)\nonumber \\
a\left(t\right) & = & \frac{d}{dt}\left[-gt+v\left(0\right)\right]=-g\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard

\color red
kürzen
\end_layout

\begin_layout Standard
Für die computerunterstützte Berechnung von Simulationen dieser Art können
 verschiedene Techniken angewandt werden.
 Dabei gibt es Grundsätzlich zwei verschiedene Vorgehen: symbolische oder
 numerische.
 Unsere Simulation übernimmt das numerische Verfahren, wie es auch Berkeley
 Madonna tut.
 Das Vorgehen beruht auf einer numerischen Approximation von Gewöhnlichen
 Differentialgleichungen.
 Diese Art kann nur Differentialgleichung 1.
 Ordnung berechnen.
 Eine Differentialgleichungen 2.
 Ordnung ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:odezweite"

\end_inset

 zu sehen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\ddot{s}\left(t\right)=-g\label{eq:odezweite}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Eine Gewöhnliche Differentialgleichung 
\begin_inset Formula $n.$
\end_inset

 Ordnung kann aber in 
\begin_inset Formula $n$
\end_inset

 Differentialgleichungen 
\begin_inset Formula $1.$
\end_inset

 Ordnung umgeformt werden.
 In den Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:zweiodeerste"

\end_inset

 wird die Differentialgleichung 
\begin_inset Formula $2.$
\end_inset

 Ordnung in zwei Differentialgleichung
\begin_inset Formula $1.$
\end_inset

 Ordnung umgewandelt.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\dot{v}\left(t\right) & = & -g\label{eq:zweiodeerste}\\
\dot{s}\left(t\right) & = & v\left(t\right)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
In unserer Simulation haben wir verschiedene numerische Verfahren implementiert,
 die wir nachfolgen kurz behandeln werden.
\end_layout

\begin_layout Standard

\color red
ODE: warum gute Beschreibung bio.
 Systeme?
\end_layout

\begin_layout Standard

\color red
(warum PDE angezeigt)
\end_layout

\begin_layout Standard

\color red
analytische vs.
 numerische Lösungen
\end_layout

\begin_layout Subsubsection*
Euler
\end_layout

\begin_layout Standard
Das Euler-Verfahren, von 
\series bold
Leonard Euler
\series default
 1768 in seinem Buch 
\shape italic
Institutiones Calculi Integralis
\shape default
 präsentiert, ist ein einfaches numerisches Verfahren.
 Von einer Schrittweite 
\begin_inset Formula $h$
\end_inset

 multipliziert mit der Ableitung 
\begin_inset Formula $y'=f$
\end_inset

 zählt man den Anfangswert 
\begin_inset Formula $y_{0}$
\end_inset

 dazu und bekommt 
\begin_inset Formula $y_{1}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
y^{\prime} & = & f\left(t,\; y\left(t\right)\right)\label{eq:euler}\\
y_{n+1} & = & y_{n}+h\cdot f\left(t_{n},\; y_{n}\right)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
In unserem Beispiel mit der Fallbeschleunigung müssen wir das Verfahren
 zwei Mal anwenden pro Zeitschritt, da wir eine Differentialgleichung 2.
 Ordnung lösen möchten.
 Dabei müsen die Anfangswerte 
\begin_inset Formula $v_{0}$
\end_inset

 und 
\begin_inset Formula $s_{0}$
\end_inset

 sowie die Schrittweite 
\begin_inset Formula $h$
\end_inset

 bekannt sein.
\end_layout

\begin_layout Standard

\color red
kürzen
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
h & = & 0.1\\
v_{0} & = & 15\nonumber \\
s_{0} & = & 0\nonumber \\
v_{1} & = & 15+0.1\cdot\left(-9.81\right)=14.019\nonumber \\
s_{1} & = & 0+0.1\cdot\left[15+0.1\cdot\left(-9.81\right)\right]=1.4019\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Bei Differentialgleichungen 1.
 Ordnung und kleiner Schrittweite 
\begin_inset Formula $h$
\end_inset

 erhält man ausreichende Genauigkeit.
 Unser Beispiel mit 2.
 Ordnung büst bei jedem Schritt an Genauigkeit ein.
 Es gibt bessere Verfahrung, die auch Ordnungen höheren Grades mit weniger
 Genauigkeitsverlust zulassen.
\end_layout

\begin_layout Subsubsection*
Butcher Tableau
\end_layout

\begin_layout Standard
Um weitere Verfahren besser zu Verstehen, wird zuerst eine Tabelle eingeführt.
 Die Tabelle wurde in den 1960er Jahren von 
\series bold
John Charles Butcher
\series default
 entwickelt für den besseren Umgang mit dem nachfolgenden Runge-Kutta-Verfahren
 und nennt sich 
\shape italic
Butcher tableau
\shape default
 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:butcher"

\end_inset

.
 Die Tabelle beinhaltet einen Vektor 
\begin_inset Formula $c_{i}$
\end_inset

, eine Matrix 
\begin_inset Formula $A=\left(a_{ij}\right)$
\end_inset

 und einen Vektor 
\begin_inset Formula $b_{i}$
\end_inset

 wobei 
\begin_inset Formula $i,=1,...,s,\; j=1,...,s$
\end_inset

 die Zeilen- und Spalten-Indizes und 
\begin_inset Formula $s$
\end_inset

 die Dimension ist.
 Verwendet wird nur ein Teil der Matrix 
\begin_inset Formula $A$
\end_inset

, nähmlich ein Dreieck von 
\begin_inset Formula $a_{21}$
\end_inset

 schräg herunter zu 
\begin_inset Formula $a_{s\left(s-1\right)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\begin{array}{c|c}
c & A\\
\hline  & b^{T}
\end{array}=\begin{array}{c|cccc}
c_{1} & a_{11} & a_{12} & \dots & a_{1s}\\
c_{2} & a_{21} & a_{22} & \dots & a_{2s}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
c_{s} & a_{s1} & a_{s2} & \dots & a_{ss}\\
\hline  & b_{1} & b_{2} & \dots & b_{s}
\end{array}=\begin{array}{c|cccc}
0\\
c_{2} & a_{21}\\
\vdots & \vdots & \ddots\\
c_{s} & a_{s1} & \dots & a_{s\left(s-1\right)}\\
\hline  & b_{1} & b_{2} & \dots & b_{s}
\end{array}\label{eq:butcher}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Wie beim Euler-Verfahren in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:euler"

\end_inset

 ergibt sich ein neuer Wert 
\begin_inset Formula $y_{n+1}$
\end_inset

 aus dem alten Wert 
\begin_inset Formula $y_{n}$
\end_inset

 addiert mit einer festen Schrittweite 
\begin_inset Formula $h$
\end_inset

 multiplitiert mit der Ableitung.
 Doch beim Runge-Kutta-Verfahren werden statt einer Ableitung verschieden
 gewichtete Ableitungen 
\begin_inset Formula $b_{i}k_{i}$
\end_inset

 aufsummiert, wobei das Gewicht 
\begin_inset Formula $b_{i}$
\end_inset

 und die Ableitung 
\begin_inset Formula $k_{i}$
\end_inset

 ist.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{n+1}=y_{n}+h\sum_{i=1}^{s}b_{i}k_{i}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Eine Ableitung, auch Zwischenschritt genannt, ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:intermstep"

\end_inset

 erläutert.
 Je grösser die Dimension 
\begin_inset Formula $s$
\end_inset

 ist, desto mehr Zwischenschritte werden berechnet.
 Zu Beginn jedes Schrittes wird der Vektor 
\begin_inset Formula $k_{i}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
 zurückgesetzt.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
k_{i}=f\left(t_{n}+hc_{i},\; y_{n}+h\sum_{j=1}^{s}a_{ij}k_{j}\right),\; i=1,...,s\label{eq:intermstep}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Für den ersten Parameter der Funktion 
\begin_inset Formula $f\left(t\; y\left(t\right)\right)$
\end_inset

 benötigen wir einen Koeffizienten 
\begin_inset Formula $c_{i}$
\end_inset

, der die unabhängige Variable 
\begin_inset Formula $t_{n}$
\end_inset

 variert.
 Jedes 
\begin_inset Formula $c_{i},\; i=1,...,s$
\end_inset

 bildet eine Summe aller Elemente eine Zeile der Matrix 
\begin_inset Formula $A=\left(a_{ij}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
c_{i}=\sum_{j=1}^{s}a_{ij}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection*
Klassisches Runge-Kutta
\end_layout

\begin_layout Standard
Um eine bessere Genauigkeit zu erhalten haben 
\series bold
Carl Runge
\series default
 und 
\series bold
Martin Wilhelm Kutta
\series default
 1900, 60 Jahre vor der Präsentation des 
\shape italic
Buchter Tableaus
\shape default
, ein leistungsfähigeres Verfahren als Euler in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:euler"

\end_inset

 entwickelt, die Differentialgleichungen numerisch zu lösen.
 Das heisst, sie kannten die Möglichkeit noch nicht, die Nachfolgen soll
 jedoch der Ansatz des des Buchter Tableau verwendet werden.
 Dabei rechnet das Klassische 4 Zwischenschritte, arbeitet also mit Dimension
 
\begin_inset Formula $s=4$
\end_inset

.
 Die Tabelle und die dazugehörigen Gleichungen sind in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rk4-table"

\end_inset

 zu finden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\begin{array}{c|cccc}
0\\
\frac{1}{2} & \frac{1}{2}\\
\frac{1}{2} & 0 & \frac{1}{2}\\
1 & 0 & 0 & 1\\
\hline  & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
\end{array}\label{eq:rk4-table}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
k_{1} & = & f(t_{n},\; y_{n})\\
k_{2} & = & f(t_{n}+hc_{2},\; y_{n}+h\cdot\left[a_{21}k_{1}\right])\\
k_{3} & = & f(t_{n}+hc_{3},\; y_{n}+h\cdot\left[a_{31}k_{1}+a_{32}k_{2}\right])\\
k_{4} & = & f(t_{n}+hc_{4},\; y_{n}+h\cdot\left[a_{41}k_{1}+a_{42}k_{2}+a_{43}k_{3}\right])
\end{eqnarray*}

\end_inset


\begin_inset Formula 
\begin{eqnarray*}
k_{1} & = & f(t_{n},\; y_{n})\\
k_{2} & = & f(t_{n}+h\cdot\frac{1}{2},\; y_{n}+h\cdot\frac{1}{2}\cdot k_{1})\\
k_{3} & = & f(t_{n}+h\cdot\frac{1}{2},\; y_{n}+h\cdot\frac{1}{2}\cdot k_{2})\\
k_{4} & = & f(t_{n}+h\cdot1,\; y_{n}+h\cdot1\cdot k_{3})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
y_{n+1}=y_{n}+h\cdot\left(\frac{1}{6}\cdot k_{1}+\frac{1}{3}\cdot k_{2}+\frac{1}{3}\cdot k_{3}+\frac{1}{6}\cdot k_{4}\right)
\]

\end_inset


\end_layout

\begin_layout Paragraph
Dormand-Prince
\end_layout

\begin_layout Standard
f
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Gradienten-Verfahren
\end_layout

\begin_layout Section
Methode
\end_layout

\begin_layout Standard

\color red
Diffusionsgleichung, Meso-> stoff konsumieren / ausscheiden
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/model-uebersicht.png
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
bli
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Legende
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/model-uebersicht-legende.png
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
bla
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es kann entweder ein Herkömmliches «Flow-Modell» erstellt werden, das bereits
 bekannt ist da es vom Konzept her identisch bereits von vielen Simulationstools
 angeboten wird.
 Oder es kann ein «XY-Modell» erstellt werden, das dann Meso Kopartments
 beinhaltet, diese befinden sich an einer Position (X / Y) und verweisen
 auf ein Modell («Flow-Model-X»).
 Im «XY-Modell» könne sich «Dichten» befinden, das sind Stoffe die eine
 gewisse Konzentration an einer gewissen Stelle aufweisen.
 Ein Meso Kompartment kann sich wären der Simulation im «XY-Modell» bewegen,
 es kann Dichten konsumieren oder produzieren.
\end_layout

\begin_layout Section
Werkzeuge und Hilfsmittel
\end_layout

\begin_layout Standard
Wie ist Lösung und warum diese Lösung?
\end_layout

\begin_layout Standard
Problem beschreiben: herausfinden was Problem ist / wo Problem ist und Lösungen
 finden
\end_layout

\begin_layout Subsection
Programmiersprachen
\end_layout

\begin_layout Standard
Als Programmiersprache kam Java zum Einsatz.
 Java ist Plattform unabhängig und sehr angenehm zum Programmieren.
 Es existieren gute Bibliotheken für grafische Darstellungen, und Java war
 bereits beiden Studierenden bekannt.
\end_layout

\begin_layout Subsection
Markup Language
\end_layout

\begin_layout Standard

\color red
Was ist eine Markup Language?
\end_layout

\begin_layout Standard

\color red
Warum dieser Weg?
\end_layout

\begin_layout Standard
Als Markup Language für die Simulation kam der Matlab Syntax zum Einsatz,
 der ebenfalls vom Open Source Tool «octave» verarbeitet werden kann.
\end_layout

\begin_layout Subsection
Entwicklungsumgebung
\end_layout

\begin_layout Standard

\color red
statt 
\begin_inset Quotes eld
\end_inset

Andreas Ba und Andreas Bu
\begin_inset Quotes erd
\end_inset

 besser 
\begin_inset Quotes eld
\end_inset

es wurde
\begin_inset Quotes erd
\end_inset

 -> nicht personifizieren
\end_layout

\begin_layout Standard
Bei Java ist man nicht fest an eine Entwicklungsumgebung gebunden.
 Das Projekt kann mit Hilfe der Ant-Buildfiles automatisch kompiliert werden,
 somit war es kein Problem das Andreas Bachmann IntelliJ und Andreas Butti
 Eclipse als Entwicklungsumgebung verwendet hat.
\end_layout

\begin_layout Standard
Es kam JDK 1.6 (Java 6) zum Einsatz, obwohl unterdessen Java 7 erschienen
 ist sind wir bei 6 geblieben, denn es ist immer noch sehr verbreitet, und
 Java 7 würde uns keinen Vorteil bringen.
\end_layout

\begin_layout Subsection
Plugin Handling
\end_layout

\begin_layout Standard
Die Applikation hat einige Punkte, die sinvollerweise durch Plugins erweitert
 werden können.
 Es gibt bereits fertige Frameworks die Pluginhandlings ermöglichen, eines
 der bekannten ist Eclipse mit dem OSGi.
 Dieses basiert auf Extension Points und Extensions, welche wider Extensio
 Pointes bereitstellen können.
 Die komplette Applikation wird dann als Plugin aufgebaut, Abhängigkeiten
 können spezifiziert werden und Seiteneffekte können vermieden werden durch
 die Abschottung einzelner Plugins gegeneinander.
 Sogar das mehrfache Laden einer Library in verschiedenen Versionen ist
 ohne Probleme möglich.
\end_layout

\begin_layout Standard
Für unsere Applikation ist soviel Flexibilität aber nicht nötige, zudem
 würde dies auch einen hohen mehraufwand bei der Implementation bedeutet.
\end_layout

\begin_layout Standard
Unsere Pluginimplementation funktioniert daher viel einfacher:
\end_layout

\begin_layout Enumerate
Es wird ein Interface für ein Plugin definiert, dies geschieht in der Hauptappli
kation
\end_layout

\begin_layout Enumerate
Ein Plugin implementiert diese Schnittstelle.
 Zudem wird ein XML File erstellt, indem steht
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Name des Plugins
\end_layout

\begin_layout Enumerate
Eine Beschreibung
\end_layout

\begin_layout Enumerate
Der Autor
\end_layout

\begin_layout Enumerate
Die Klasse die geladen werden soll beim Start des Plugins
\end_layout

\end_deeper
\begin_layout Enumerate
Der Javacode und das XML File werden in ein .jar gepackt und in einem vordefinier
ten Ordner abgelegt (meist konfigurierbar in config.properties)
\end_layout

\begin_layout Enumerate
Die Applikation durchsucht beim Start diesen Ordner, öffnet alle .jar Dateien
 und lädt das plugin.xml File.
 Hat dies alles geklappt wird das Jarfile in den aktuellen Kontext geladen
 und die Klasse ausgeführt
\end_layout

\begin_layout Enumerate
Es gibt keine Querabhängigkeiten, das Plugin wird direkt in den Applikationkonte
xt geladen, und hat vollen Zugriff auf die Applikation
\end_layout

\begin_layout Standard
Es sind momentan zwei Pluginschnittstellen vorhanden
\end_layout

\begin_layout Enumerate
Laden von Fremdformate: Plugins für Berkeley Madonna und Dynasys sind vorhanden,
 siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Fremdformat-importe"

\end_inset


\end_layout

\begin_layout Enumerate
Simulation: Plugins für Interne Simulation und Matlab Codegeneration: TODO
 Querverweis
\end_layout

\begin_layout Subsection
Dateiformat
\end_layout

\begin_layout Standard
Als Dateiformat wird ein eigens entwickeltes, auf XML basierendes Dateiformat
 verwendet.
 Dieses Dateiformat spiegelt die Internen Strukturen ziemlich genau ab.
 Zudem gibt es Plugin Schnittstelle um Fremdformate zu importieren, es ist
 somit möglich beliebige Fremdformate zu importieren, es muss dafür lediglich
 ein Plugin erstellt werden und im richtigen Verzeichnis abgelegt werden.
\end_layout

\begin_layout Paragraph
Fremdformat importe
\begin_inset CommandInset label
LatexCommand label
name "par:Fremdformat-importe"

\end_inset


\end_layout

\begin_layout Standard
Es wurden zwei Importplugins erstellt, eins für Berkeley Madonna, uns eins
 für Dynasys.
 Um einen sinnvollen Test der Pluginschnittstelle vorzunehmen waren zwei
 Plugins notwendig.
\end_layout

\begin_layout Standard
Dynasys ist seit 2009 unter der GPL freigegeben, somit war ein Einblick
 in den Pascal Code möglich.
 Die Pascal Objekte wurden binär serialisiert, und da es sich bei Dynasys
 noch um eine 16bit Applikation handelt werden nicht alle Daten korrekt
 eingelesen.
 Trotz Einschränkungen ist es somit möglich kleinere Dateien komplett, und
 grössere Dateien teilweise einzulesen.
\end_layout

\begin_layout Standard
Bei Berkeley Madonna war kein Quellcode verfügbar, jedoch basiert der grafische
 Modellierungsteil von Berkeley Madonna auf Java.
 Die Datei an sich ist binär, enthält jedoch die Magic Bytes 0xACED, welches
 von Java als Start für eine Object Stream verwendet werden.
 Der Stream enthält nur primitive Datentypen, und Objekte aus der Java Runtime,
 es müssen also keine spezifischen Klassen vorhanden sein.
 Mit Beispieldateien war es möglich das Format zu reverse engeneeren.
 Es wird nicht alles korrekt importiert, es konnten jedoch die aus der Physikvor
lesung vorhandenen Dateien korrekt importiert werden.
\end_layout

\begin_layout Standard
Die Nächste Version von Berkeley Madonna, Version 9, verwendet nun aber
 ein neues, XML basierendes Format, welches nicht implementiert wurde.
 Es könnte jedoch auch dieses Format mit einem zusätzlichen Plugin eingelesen
 werden.
\end_layout

\begin_layout Standard
TODO => http://docs.oracle.com/javase/6/docs/platform/serialization/spec/protocol.h
tml
\end_layout

\begin_layout Paragraph*
Internes Dateiformat
\end_layout

\begin_layout Standard
Die von (AB)² Simulation erstellen Dateien enden auf .simz, es handelt sich
 dabei um ein standard ZIP-File, welches 4 Files enthält:
\end_layout

\begin_layout Itemize
configuration.xml
\end_layout

\begin_layout Itemize
mimetype
\end_layout

\begin_layout Itemize
simulation.xml
\end_layout

\begin_layout Itemize
version
\end_layout

\begin_layout Standard
Version ist ein Java Property File, mit zwei Einträgen:
\end_layout

\begin_layout Quote
version=1
\end_layout

\begin_layout Quote
compatible=1
\end_layout

\begin_layout Standard
«version» ist ein Ganzzahlwert, die Version die Datei, «compatible» ist
 ebenfalls eine Ganzzahl, die angibt mit welcher Version die Datei immer
 noch eingelesen werden kann, ohne das Probleme auftreten.
 Kleinere Unstimmigkeiten werden in Kauf genommen, aber das Modell kann
 immer noch eingelesen werden, somit ist die Rückwärtskompatibilität genau
 geregelt.
\end_layout

\begin_layout Standard
Wird eine Inkompatible Änderung am Dateiformat vorgenommen, so müssen beide
 Versionsnummern um eins hochgezählt werden, wird eine kompatible Erweiterung
 am Dateisystem vorgenommen so wird lediglich «version» hochgezählt.
\end_layout

\begin_layout Standard
mimetype ist ein Textfile mit einem einzigen String, «application/zhaw.simulation.
project».
 Diese Datei wird oft verwendet um den Typ eines auf Zipbasierenden Dateiformats
 zu erkennen.
 Zum Beispiel verwendet .odt als mimetype «application/vnd.oasis.opendocument.text»,
 dank solchen Kennungen kann Zipfile eindeutig als gültiges Simulationsfile
 erkennen.
\end_layout

\begin_layout Standard
configuration.xml enthält die Konfiguration der Plugins, z.B.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=html]
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<simconfig>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.dt" value="0.1"/>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.end" value="5.0"/>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.start" value="0.0"/>
\end_layout

\begin_layout Plain Layout

</simconfig>
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Einstellungen können von den Plugins beliebig festgelegt werden, hier
 sind nur Einstellungen gespiechert, und keine Business Daten.
\end_layout

\begin_layout Standard
simulation.xml Enthält das Modell, oder bei einem XY-Model auch mehrere Modelle.
 Diese Datei sieht folgendermassen aus (gekürzt, kommentiert):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=html]
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

    <model grid="20" height="400" type="xy" width="400" zerox="200" zeroy="200">
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="grad(&quot;d1&quot;,
 &quot;x&quot;)" directiony="1" name="m0" value="model3" x="151" y="89"/>
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="sin(1/2)" directiony="co
s(1/2)" name="m1" value="model3" x="10" y="88"/>
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="1" directiony="1"
 name="m5" value="model2" x="256" y="281"/>
\end_layout

\begin_layout Plain Layout

        <global name="g0" value="5" x="252" y="37"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        <density name="d1" text="" value="10*sin(x/20)+10*cos(y/20)"/>
\end_layout

\begin_layout Plain Layout

        <density name="d2" text="" value="x"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       <model name="model2" type="flow">
\end_layout

\begin_layout Plain Layout

            <container name="Q" value="0" x="262" y="109"/>
\end_layout

\begin_layout Plain Layout

            <parameter name="UC" value="Q/C" x="220" y="238"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

           <!-- Fluss, "helperpoint" sind die Bezier Hilfspunkte -->
\end_layout

\begin_layout Plain Layout

           <flowConnector name="I" value="UR/R">
\end_layout

\begin_layout Plain Layout

                <source>
\end_layout

\begin_layout Plain Layout

                    <helperpoint x="116" y="147"/>
\end_layout

\begin_layout Plain Layout

                    <infinite x="34" y="116"/>
\end_layout

\begin_layout Plain Layout

                </source>
\end_layout

\begin_layout Plain Layout

                <target to="Q">
\end_layout

\begin_layout Plain Layout

                    <helperpoint x="230" y="145"/>
\end_layout

\begin_layout Plain Layout

                </target>
\end_layout

\begin_layout Plain Layout

                <valve x="140" y="118"/>
\end_layout

\begin_layout Plain Layout

            </flowConnector>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            <!-- Parameter Verbindung -->
\end_layout

\begin_layout Plain Layout

            <connector from="Q" to="UC">
\end_layout

\begin_layout Plain Layout

                <helperpoint x="256" y="207"/>
\end_layout

\begin_layout Plain Layout

            </connector>
\end_layout

\begin_layout Plain Layout

        </model>
\end_layout

\begin_layout Plain Layout

        <model name="model3" type="flow">
\end_layout

\begin_layout Plain Layout

            <!-- Anderes Submodel...
 -->
\end_layout

\begin_layout Plain Layout

        </model>
\end_layout

\begin_layout Plain Layout

    </model>
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Dateiformat ist weitgehend selbsterklärend.
 Es wurde erstellt um das Modell unserer Applikation möglichst genau abzubilden.
 Es wurde nicht angestrebt einen Standard zu erschaffen / mit anderen Applikatio
nen über dieses Format zu interagieren.
\end_layout

\begin_layout Standard
Grundsätzlich gilt: jeder XML Tag entspricht einem Objekt, jedes Attribut
 eines Tags entspricht einem Attribut eines Objekts (einfaches Attribut
 wie ein String).
 Jeder Tag innerhalb eines anderen Tags entspricht einem Attribut eines
 Objekts (komplexes Attribut, z.B.
 Punkt mit zwei Koordinaten).
 Somit entspricht das Format nicht ganz den XML Richtlinien, welches alle
 relevanten Informationen als Tags und alle Metainformationen als Attribute
 abspeichert, ist aber dem Code sehr nahe und auch einfach zu verstehen.
\end_layout

\begin_layout Section
Vorgehen
\end_layout

\begin_layout Subsection
Softwarearchitektur
\end_layout

\begin_layout Subsubsection*
Projektunterteilung
\end_layout

\begin_layout Standard
Die Applikation besteht aus mehreren Javaprojekten, die hier in einer Übersicht
 kurz beschrieben werden
\end_layout

\begin_layout Enumerate

\series bold
AppDefinition:
\series default
 Dieses Projekt beinhaltet Interfaces der Applikation, die nicht im Projekt
 «Simulation» untergebracht werden konnten, da ansonsten eine Zyklische
 Abhängigkeit entstanden wäre
\end_layout

\begin_layout Enumerate

\series bold
BJavalibs:
\series default
 Generelle Java GUI Libraries von Andreas Butti, dieser Code ist grösstenteils
 vor der BA entstanden
\end_layout

\begin_layout Enumerate

\series bold
Editor:
\series default
 Abstrakter Editor für XY- und Flow Modelle.
 Beinhaltet alle basis Klassen, Globale Parameter, Clipboard, Undo / Redo,
 Toolbar / Menubar und den Formeleditor
\end_layout

\begin_layout Enumerate

\series bold
Editor.Flow:
\series default
 Der Editor für Flussdiagramme, basierend auf «Editor»
\end_layout

\begin_layout Enumerate

\series bold
Editor.XY:
\series default
 Der Editor für XY-Diagramme, basierend auf «Editor»
\end_layout

\begin_layout Enumerate

\series bold
ExternLibraries:
\series default
 Dies ist nur ein Pseudoprojekt, und beinhaltet kein Code.
 Hier sind unsere externen Libraries untergebracht.
\end_layout

\begin_deeper
\begin_layout Enumerate
JFreeChart: Diagramm Library
\end_layout

\begin_layout Enumerate
JCommon: Wird von JFreeChart benötigt
\end_layout

\begin_layout Enumerate
JXLayer: Wird verwendet um beim Simulieren den Editor Unscharf darzustellen
 und ein Statusdialog direkt im Editor darzustellen
\end_layout

\begin_layout Enumerate
SwingX: Erweiterte Swing GUI-Komponenten, werden an diversen Stellen benötigt
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
ImageExport:
\series default
 Der «Speichern als Bild» Dialog
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter:
\series default
 Definition für Importplugins
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter.Dynasys:
\series default
 Dynsys Import Plugin
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter.Madonna:
\series default
 Berkeley Madonna Import Plugin
\end_layout

\begin_layout Enumerate

\series bold
Model:
\series default
 Das «Domänenmodell», dies ist die interne Abbildung aller Daten die modelliert
 werden können.
\end_layout

\begin_layout Enumerate

\series bold
NetbeansDirchooser:
\series default
 Dieser Code entstammt dem Netbeans Projekt, es ermöglicht die komfortable
 auswahl eines Ordners, die mit Swing Boardmittel wesentlich weniger konfortabel
 wäre: Es können die Ordner wie gewohnt als Baum ausgeklappt werden.
\end_layout

\begin_layout Enumerate

\series bold
OnscreenKeyboard:
\series default
 Hierbei handelt es sich um die Tastatur für die Spezialzeichen, die bei
 Feldern im Diagramm zur Verfügung steht.
\end_layout

\begin_layout Enumerate

\series bold
Plugin:
\series default
 Dies ist die Implementation um Plugins zu laden.
 Diese 285 Zeilen Code stammen aus einem vorgängigen Projekt von Andreas
 Butti
\end_layout

\begin_layout Enumerate

\series bold
Simulation:
\series default
 Dies ist der Einsprungpunkt der Applikation.
 Hier befinden sich auch die globalen Komponenten
\end_layout

\begin_deeper
\begin_layout Enumerate
About Dialog
\end_layout

\begin_layout Enumerate
Einstellungen
\end_layout

\begin_layout Enumerate
Speichern / Laden
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
SimulationBuild:
\series default
 Dies ist ein Pseudoprojekt das nur für den Build der Applikation benötigt
 wird, es enthält kein Code
\end_layout

\begin_layout Enumerate

\series bold
SimulationDiagram:
\series default
 Dieses Projekt enthält die Darstellung eines Diagramms, obwohl das eigentliche
 Diagramm von JFreeChart dargestellt wird gibt es einiges um das Diagramm,
 wie die Legende oder die Konfiguration, welche in diesem Projekt zu finden
 sind
\end_layout

\begin_layout Enumerate

\series bold
SimulationJepLib-2.4.1:
\series default
 JEP ist ein Open Source Parser, welcher für die Interne Simulation und
 das Prüfen von Formeln eingesetzt wird.
 Da das Projekt offiziell nicht mehr supported wird wurde der Sourcecode
 komplett kopiert um kleine Fehlerkorrekturen vorzunehmen.
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin:
\series default
 Die Definition des Simulationplugins
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin.Intern:
\series default
 Interne Simulation, die Formeln werden mit JEP berechnet.
 Das Plugin unterstützt nur das Flow-Modell, das XY-Modell ist nicht implementie
rt.
 Es wird nur Runge-Kutta und Euler unterstützt.
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin.MatlabOctave:
\series default
 Dieses Plugin generiert den Matlab Markup.
 Ohne dieses Plugin ist die Simulation von XY-Modellen nicht möglich.
\end_layout

\begin_layout Enumerate

\series bold
SimulationSidebar:
\series default
 Hier befinden sich Definitionen für die Sidebar der Applikation, diese
 mussten in ein eigenes Projekt ausgelagert werden um keine Zyklischen Abhängigk
eiten zu Produzieren, gehören jedoch eigentlich zum Editor.
\end_layout

\begin_layout Enumerate

\series bold
Sysintegration:
\series default
 Hier werden die Plattform / Systemabhängigen Komponenten abgelegt, dies
 beinhaltet unter anderem
\end_layout

\begin_deeper
\begin_layout Enumerate
Alle Icons (bei der aktuellen Implementation wird jedoch nicht nach Plattform
 unterschieden)
\end_layout

\begin_layout Enumerate
Bookmark Implementationen (z.B.
 die Auswahl «Desktop» beim Speichern eines Bildes stammt von hier)
\end_layout

\begin_layout Enumerate
Toolbar Implementation: Die von Swing bereitgestellte Toolbar sieht auf
 Mac OS X komisch aus, daher hier eine angepasste Version.
 Zudem enthält diese Implementation einige für die Simulation zugeschnittene
 Anpassungen.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
VectorExport:
\series default
 Hier enthalten ist die Library Freehep und einige Helferklassen.
 Mithilfe dieses Projektes werden beim Bilderexport SVG, EMF und EPS Dateien
 erzeugt.
\end_layout

\begin_layout Enumerate

\series bold
XYResultViewer:
\series default
 Bei diesem Projekt handelt es sich um das «Diagramm» von XY-Simulationen.
 Es kann die Bewegungen und die Dichten darstellen.
 Im Gegensatz zur Darstellung von Flow-Simulationen müssen hier 3 Dimensionale
 Daten dargestellt werden.
 Die dritte Dimension ist hier die Zeit, und wird durch einen Slider dargestellt.
\end_layout

\begin_layout Standard
Die Aufteilung in 25 Projekte erscheint auf den ersten Blick etwas unübersichtli
ch, auf den zweiten Blick entsprechen die meisten Projekte aber einzelnen
 Komponenten der Applikation die auch in der Applikation entsprechend aufgeteilt
 sind, und machen daher Sinn.
 Lediglich 2 Projekte wurden aus technischen Gründen (zyklische Abhängigkeiten)
 erstellt, und entsprechen keinen eigenen Komponenten.
\end_layout

\begin_layout Subsubsection*
Design Pattern
\end_layout

\begin_layout Standard
Die Applikation wurde nach MVC (Model View Control) bzw.
 Domänenmodell aufgebaut.
 Das Bedeutet das die Daten, die Logik und der View nur lose gekoppelt sind,
 und somit auch der View ersetzt werden könnte, ohne das der Rest angepasst
 werden müsste.
 Diese beiden Designpattern beschreiben ein ziemlich ähnliches vorgehen,
 wobei MVC sich hauptsächlich auf einen GUI Komponenten beziehen lässt,
 wie z.B.
 ein TreeView, während das Domänenmodell sich auf eine komplette Applikation
 anwenden lässt.
 Beides sind Vorgehensmuster, und keine exakten Vorgaben.
\end_layout

\begin_layout Standard
Das (Domänen)Modell befindet sich im Projekt «Model» und ist entsprechend
 von allem anderen entkoppelt.
 Die Simulation ist nur vom Model abhängig, und es besteht keine direkte
 Verbindung zur GUI.
 Die Gui selbst ist ein relativ grosser Teil der Applikation, und ist auch
 nicht überall klar abgegrenzt.
\end_layout

\begin_layout Standard
Komponeten wie Undo / Redo sind bei uns komplett in der GUI untergebracht,
 da diese auch komplett von dieser abhängig sind.
 Designtechnisch ist die Einordnung solcher Komponenten nicht eindeutig,
 denn z.B.
 Undo / Redo enthält ein Modell, nämlich die letzten Änderungen.
 Es enthält zudem Logik, es kann Änderungen Rückgängig machen / Wiederherstellen.
 Es ist aber ein GUI Komponent, denn es ist 100% von der GUI abhängig.
 Wenn wir jedoch definieren das es sich bei den Undo / Redo Daten nicht
 um Business Daten, sondern um Metadaten handelt sollte es auch nach den
 Pattern kein Problem sein wenn wir es Innerhalb der GUI unterbringen.
 Zudem war dies die einzig technisch sinvolle Möglichkeit.
\end_layout

\begin_layout Subsection
Technische Beschreibung Softwarekomponenten
\end_layout

\begin_layout Subsubsection*
Model
\end_layout

\begin_layout Standard
Das Datenmodell ist wie folgendermassen aufgebaut: Der Einsprungpunkt ist
 das «SimulationDocument», welches entweder ein «SimulationFlowModel» oder
 ein «SimulationXYModel» beinhaltet.
 Sowohl das Flow als auch das XY Modell erben von , «AbstractSimulationModel»,
 dieses beinhaltet «AbstractSimulationData», welches ebenfalls eine Abstrakte
 Klasse für alle Simulationskomponenten darstellt, wie
\end_layout

\begin_layout Itemize
Container
\end_layout

\begin_layout Itemize
Parameter
\end_layout

\begin_layout Itemize
Global
\end_layout

\begin_layout Itemize
Meso Kompartment.
\end_layout

\begin_layout Standard
«SimulationFlowModel» enthält zusätzlich noch Verbindungen, welche entweder
 ein Fluss oder eine Parameterverbidung darstellen.
 Abgebildet werden diese als «AbstractConnectorData<?>».
 Wobei der Fluss «FlowConnectorData» und der «ParameterConnectorData» die
 beiden möglichen Implementationen darstellen.
\end_layout

\begin_layout Standard
«SimulationXYModel» enthält zusätzlich zur Basisklasse noch Dichten, welche
 von der Klasse «DensityData» sind, hier besteht keine Abstraktion, es gibt
 nur eine Implementation.
\end_layout

\begin_layout Standard
Zudem kann ein XY Model beliebig viele Flow Modelle enthalten, welche über
 «SubModelList» gehandelt werden.
\end_layout

\begin_layout Standard
Die Modelle enthalten jede Menge an Methoden zur Manipulation der Daten,
 welche hier nicht aufgeführt werden, diese können der Codedokumentation
 oder dem Code entnommen werden.
\end_layout

\begin_layout Subsubsection*
Editor
\end_layout

\begin_layout Standard
Der Editor ist einer der komplexesten Elemente dieser Applikation.
\end_layout

\begin_layout Subsection
Tests und Validierung
\end_layout

\begin_layout Standard
Test der Matheengine, Vergleich mit Berkeley-Madonna
\end_layout

\begin_layout Section
Resultate
\end_layout

\begin_layout Standard
Beschreibung, Screenshots, Beispielsimulationen mit Ergebniss-Diagramm
\end_layout

\begin_layout Section
Diskussion und Ausblick
\end_layout

\begin_layout Subsection*
Markup Language
\end_layout

\begin_layout Standard
Wir haben uns die Matlab Markup Language entschieden, da wir auf viele vordefini
erten Funktionen (
\begin_inset Quotes eld
\end_inset

Toolbox
\begin_inset Quotes erd
\end_inset

) zurückgreifen konnten, und uns somit den Mathematischen Teil teilweise
 vereinfachen.
\end_layout

\begin_layout Standard
Es haben sich jedoch immer wider Probleme mit den in Matlab vordefinierten
 Funktionen ergeben, grundsätzlich erfüllen die Funktionen unsere Anforderungen,
 dies haben wir auch vorgängig abgeklärt, jedoch sind bei der Verwendung
 Probleme aufgetreten, die die Verwendung der Toolboxfunktionen verunmöglichten.
\end_layout

\begin_layout Itemize
Numerische Integration: Es kann zwar ein Integral numerisch integriert werden,
 jedoch müssen wir mehrere Integrale Simultan lösen, was von der Matlab
 Toolbox nicht unterstützt wird
\end_layout

\begin_layout Itemize
Gradienten berechnen mit 
\begin_inset Quotes eld
\end_inset

grad
\begin_inset Quotes erd
\end_inset

: Wird ein Gradienten im Diskreten Raum berechnet, so tritt immer das Problem
 auf das die Zahlen in einem Gitter abgelegt werden müssen, was mathematisch
 natürlich falsch ist.
 Matlab versucht den Mathematischen Fehler gleichmässig auf alle Richtungen
 zu verteilen, dies bedeutet das wenn eine Spitze abgeleitet wird, so entsteht
 ein Plateu.
 Diese Plateus sind für unsere Simulation extrem ungünstig.
 Daher haben wir jetzt einen Gradienten implementiert der einfach um 0.5
 Einheiten im Raster verschoben ist.
 Dies bewirkt zwar ein Abdriften in eine Richtung, ist jedoch bei der Simulation
 wesentlich weniger schlimm als ein Plateu.
 Ein Plateu kann bewirken das sich ein Meso Kompartment, welches sich zur
 nidrigsten Konzentration bewegen soll, nicht mehr bewegt.
\end_layout

\begin_layout Standard
Wir erstellen nun den Kompletten Matlab Code selbst, es werden keine Toolboxen
 verwendet.
 Nach dem erstellen eines Temporären Files wird ein neuer Matlab / Octave
 Prozess erstellt, und dieser führt die Simulation aus.
\end_layout

\begin_layout Standard
Leider hat sich das Fehlerhandling viel schwieriger gestaltet als erwartet,
 denn z.B.
 Matlab beendet sich nicht nach einem Fehler mit einem entsprechenden Exit
 Code, sondern geht in den Interaktiven Modus über.
\end_layout

\begin_layout Standard
Zudem ist die Plattformunabhängigkeit nicht gewährleistet, denn es muss
 für jede Plattform separat getestet werden, was wir auch gemacht haben
 und festgestellt haben das es nicht auf allen Plattformen funktioniert.
\end_layout

\begin_layout Standard
Aufgrund aller dieser Tatsachen haben wir entschieden das der weg mit einer
 Markup Language der falsche war:
\end_layout

\begin_layout Itemize
Fehlerhändling schwirig
\end_layout

\begin_layout Itemize
Plattformunabhängigkeit funktioniert nur bedingt
\end_layout

\begin_layout Itemize
Keine Programmiertechnischen Vorteile
\end_layout

\begin_layout Itemize
Geschwindigkeitseinbussen (bei kleinen Simulationen fällt insbesondere der
 Start einer externen Applikation stark ins Gewicht)
\end_layout

\begin_layout Standard
Wir haben daher entschieden das eine zukünftige Entwicklung nicht auf dieser
 Basis, sondern der Code komplett intern ausgeführt wird.
 Daher haben wir auch keine Zeit mehr ins Fehlerhandling / Plattformunabhängigke
it etc.
 investiert.
 Eine Interne Simulation bringt zusätzlich folgende Vorteile:
\end_layout

\begin_layout Itemize
Eine Formel, die bei der Eingabe vom Parser validiert wurde ist auch zu
 100%ig sicher ausführbar, wenn eine Formel mit dem Internen Parser validiert
 wurde und dann als Matlab Code ausgegeben wird ist dies nicht sicher, denn
 die Parser unterscheiden sich in Details, die unter Umständen nicht alle
 korrekt gehändelt werden.
 Zudem wird jede Formel beim internen Parser in einem separaten Kontext
 ausgeführt, was bei Matlab nicht der Fall ist, somit können unter ungünstigen
 Umständen Seiteneffekte auftreten, welche beim Internen Parser praktisch
 ausgeschlossen sind.
\end_layout

\begin_layout Itemize
Fehler sind immer gehändelt, und können normalerweise Ihren Ursprungsobjekt
 zugeordnet werden (z.B.
 einem Container), wenn im Matlab Code ein Fehler auftritt kann dieser nur
 einer Zeile zugeordnet werden, es ist jedoch für den Anwender nicht offensichtl
ich wo der Ursprung des Fehlers liegt.
\end_layout

\begin_layout Itemize
Die Simulation kann einfach abgebrochen werden: Wenn die externe Simulation
 abgebrochen werden muss ist dies wesentlich komplizierter, und funktioniert
 ggf.
 nicht unter allen Umständen.
\end_layout

\begin_layout Itemize
Parallelisierung: Heutzutage besitzt jeder moderne PC mehr als einen Rechenkern.
 Mit Matlab / Octave ist es jedoch nicht möglich dies zu nutzen.
 Bei einer Internen Simulation wäre dies möglich, wenn auch aufwendig.
 Somit könnte die Simulation grösserer Modelle um Faktoren beschleunigt
 werden.
 (Voraussetzung: mehr als ein Core, und das Modell muss entsprechend unabhängige
 Teile aufweisen, ein Aufteilen eines einzelnen Integrals ist theoretisch
 zwar möglich, praktisch ist es jedoch langsamer als die Simulation auf
 einem CPU, da die Synchronisation sehr viel Leistung benötigt) => MPC
\end_layout

\begin_layout Subsection*
TODO
\end_layout

\begin_layout Standard
Was Fehlt noch, was muss noch gemacht werden? Interpretation und Validierung
 der Resultate Rückblick auf Aufgabenstellung, erreicht bzw.
 nicht erreicht Legt dar, wie an die Resultate (konkret vom Industriepartner
 oder weiteren Forschungsarbeiten; allgemein) angeschlossen werden kann;
 legt dar, welche Chancen die Resultate bieten 18
\end_layout

\begin_layout Section
Verzeichnisse
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand
\backslash
refname{
\backslash
subsection{Literaturverzeichnis}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "din1505/alphadin"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Glossar
\end_layout

\begin_layout Standard
Meso-Kompartment: Ein Teil des XY-Simulationsmodells
\end_layout

\end_body
\end_document
