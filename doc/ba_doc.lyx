#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Codeformatting
\usepackage{listings}
\usepackage{courier}
\usepackage{caption}

\lstset{
aboveskip=10pt,
belowskip=10pt,
basicstyle=\footnotesize\ttfamily,	% Standardschrift
numbers=left,	% Ort der Zeilennummern
numberstyle=\tiny,	% Stil der Zeilennummern
%stepnumber=2,	% Abstand zwischen den Zeilennummern
numbersep=5pt,	% Abstand der Nummern zum Text
tabsize=4,		% Groesse von Tabs
extendedchars=true,	%
breaklines=true,	% Zeilen werden Umgebrochen
keywordstyle=\color{blue}, % Farbe für die Keywords wie public, void, object u.s.w.
commentstyle=\color{green}, % Farbe der Kommentare
stringstyle=\color{red}, % Farbe der Zeichenketten
frame=b, % Linie unten
showspaces=false,           % Leerzeichen anzeigen?
showtabs=false,             % Tabs anzeigen?
xleftmargin=17pt,
framexleftmargin=17pt,
framexrightmargin=5pt,
framexbottommargin=4pt,
showstringspaces=false      % Leerzeichen in Strings anzeigen?
}

 \lstloadlanguages{% Check Dokumentation for further languages ...
%[Visual]Basic
%Pascal
%C
%C++
XML
%HTML
%Java
 }
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tabelle

\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.25}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{wallpaper}
\usepackage{anysize}
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Entwicklung eines graphischen Editors zur Modellierung von Systemen mit dynamischer Modellstruktur"
\pdf_author "Andreas Bachmann, Andreas Butti"
\pdf_subject "(AB)² Simulation"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
include{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
Englische Version von “Zusammenfassung”
\end_layout

\begin_layout Section*
Zusammenfassung
\end_layout

\begin_layout Standard
Wird erst am Ende der Arbeit geschrieben
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Vorwort
\end_layout

\begin_layout Standard

\color red
(= persönliches)
\end_layout

\begin_layout Standard
In der Forschung aber auch zu Unterrichtszwecken werden viele Theorien vermittel
t und Simuliert.
 Solche Simulationen basieren meistens auf einem strikt mathematischen Hintergru
nd, meist Integrale erster Ordnung.
 Forschende Personen im Bereich Physik/Biologie verwenden dabei bevorzugt
 eine Modellierungssoftware, da es nicht ihr Fachgebiet ist, selbst zu programmi
eren.
 Andreas Butti hat sich bei der Verwendung von Simulationstools über deren
 Plattformunabhängigkeit und Benutzerunfreundlichkeit gestört.
 Als Informatiker kommt man da schnell in Versuchung, selbst etwas besserer
 zu schreiben.
 Nach einem Gespräch mit dem Physikdozenten, Herr Scheidegger, wurde daraus
 dann diese BA, die jedoch nicht nur ein benutzerfreundliches Simulationswertzeu
g sein soll, sondern auch bisher nicht vorhandene Möglichkeiten für die
 Simulationen von Biologischen Abläufen, wie das innere einer Zelle, darstellen
 soll.
 
\color red
TODO: Danksagung
\color inherit

\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Hauptteil
\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Standard

\color red
fusion->trennen von Meso (nicht implementiert)
\end_layout

\begin_layout Standard

\color red
FSM->nicht invivo ==============> Ist so nun OK? A.B.
\end_layout

\begin_layout Standard
Es gibt bereits viele Simulationstools, wie z.B.
 Berekely Madonna, um nur ein bekanntes Beispiel zu nennen.
 Diese Tools unterstützten die Modelierung von Differentialgleichungen als
 Modell, mit Containern und Flüssen.
 Dann gibt es Tools wie SimuLink, dies Simuliert keine Flüsse sondern elektronis
che Komponenten wie Verstärker und Kondensatoren.
 Mathematisch laufen beide Ansätze auf ähnliche Lösungen heraus.
 Was aber bei beiden Tools nicht möglich ist, die Simulation kompartimentaler
 Systeme wie Sie in der Biologie vorkommen.
 Wenn eine Zelle simuliert werden soll müssen die einzelnen Bestandteile
 (Meso-Kompartimente) sich in einem Bereich frei bewegen könne und mit den
 anderen Bestandteilen interagieren über die Umgebung.
 Dies ist mit bisherigen Lösungen nicht möglich, und wurde nun von uns realisier
t.
\end_layout

\begin_layout Standard
Da unsere Simulation keinen elektrotechnischen Hintergrund hat, haben wir
 für die Darstellungen unserer Flussmodelle ebenfalls Container mit Flüssen
 (Integral) verwendet.
\end_layout

\begin_layout Subsection
Vorgabe
\end_layout

\begin_layout Standard
Bestehende graphische Modelleditoren erlauben eine effiziente Modellierung
 von kompartimentalen Systemen.
 Dabei unterstützt die graphische Oberfläche die Strukturierung des Modells
 bzw.
 des Systems.
 Dies kann gerade bei der Erfassung von komplexen Systemen den Zugang zu
 einer adäquaten Systembeschreibung erleichtern.
 Gerade aber Modelleditoren wie Berkeley-Madonna sind auf eine kompartimentale
 Struktur des Systems angewiesen.
 Räumlich strukturierte bzw.
 verteilte Systeme lassen sich nur schwer und in vereinfachter Form abbilden.
 Die Verwendung oder Kopplung verschiedener Simulationswerkzeuge kann für
 gewisse technische Systeme in Betracht gezogen werden (z.B.
 elektrische Schaltung mit Komponenten, bei denen die Wärmeabstrahlung und/oder
 Wärmeleitung räumlich modelliert werden).
 Bei vielen Systemen lässt sich aber durch eine solche Kopplung das System
 nicht abbilden.
 Bei biologischen Systemen z.B.
 können sich Kompartimente bewegen (bei Zellen z.B.
 Chemo- und Haptotaxis).
 Zudem zeichnen sich biologische Systeme durch hierarchische Kompartimentstruktu
ren mit Unterkompartimenten aus.
 Ein weiterer Aspekt betrifft die Möglichkeit, dass Kompartimente in biologische
n Systemen fusionieren oder sich teilen können.
\end_layout

\begin_layout Standard
Anforderungen: Das zu entwickelnde Modellierungswerkzeug soll an die intuitive
 graphische Oberfläche bestehender Modellierungswerkzeuge für kompartimentale
 Simulationen anknüpfen.
 Folgende Aspekte sollen konzeptuell untersucht und wenn möglich implementiert
 werden:
\end_layout

\begin_layout Itemize
Hierarchische Kompartimente
\end_layout

\begin_layout Itemize
Räumliche Positionierung von Kompartimenten, welche die Wechselwirkung der
 Kompartimente auf gleicher Stufe beeinflussen kann und somit Einführung
 von Koordinaten (erster Schritt 2-Dim.) bzw.
 orthogonales Grid und Beschreibung von Gradienten (z.B.
 für Änderung der räumlichen Position von Kompartimenten aufgrund von z.B.
 Gradienten)
\end_layout

\begin_layout Itemize
Ausgabe eines Codes in einer Markup Langauge (z.B.
 SBML), welcher von einem bestehenden Solver ausgeführt werden kann (z.B.
 Matlab)
\end_layout

\begin_layout Subsection
Problemstellung (oder Motivation)
\end_layout

\begin_layout Standard

\color red
Motivation durch Problemstellung! signalig chains (SimuLink), Biologie.
 Motivation->Problem->Insiliko
\end_layout

\begin_layout Standard
Statt: unsere Simulation, Andreas, oder so andere Formen wählen
\end_layout

\begin_layout Standard

\color magenta
Mit unserer Simulation
\color inherit
 ist es zusätzlich möglich in einem XY Modell mehrere Meso-Kompartimente
 abzubilden, ein Meso-Kompartment ist das vorhin genannte Flussmodel.
 Diese Meso-Kompartimente können sich wären der Simulation im XY-Raum bewegen.
 Es können Dichten angegeben werden, die über den XY Raum verteilt sind,
 und die Meso-Kompartimente können an Ihrer aktuellen Position von der Dichte
 konsumieren oder Dichte produzieren, somit kann die Umgebung beeinflusst
 werden.
 Mit diesen Fähigkeiten ist es möglich, das Innenleben einer Zelle oder
 andere biologische Prozesse einfach, grafisch abzubilden.
 Die Idee und Vorgabe dieser Simulationsmethode stammt von Herr Scheidegger,
 und wurde zusammen mit Herr Füchslin und uns ausgearbeitet.
\end_layout

\begin_layout Section
Theorie
\end_layout

\begin_layout Standard
Um biologische Prozesse zu verstehen und nachzubilden, werden mathematische
 Systeme modelliert und danach mit rechnerunterstützten Solvern Näherungslösunge
n berechnet.
 Als Beispiel kann sich die Population 
\begin_inset Formula $N\left(t\right)$
\end_inset

 eines Bakterienvolkes in einer Petrischale mit der Zeit ändern, je nachdem,
 welche äusseren Einflüsse auf die Bakterien einwirken.
 Die Geburten- und Sterberate bilden die Änderung 
\begin_inset Formula $\frac{dN}{dt}$
\end_inset

 der Population 
\begin_inset Formula $N\left(t\right)$
\end_inset

.
 Dabei werden oftmals Differentialgleichung (DGL) verwendet.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{dN}{dt} & = & Geburtenrate-Sterberate
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Im Falle von Bakterien kann von einem exponentiellen Wachstum ausgegangen
 werden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{dN}{dt} & = & \alpha N-\beta N^{2},\quad N\geq0
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Das Wachstum kann Beschränkt werden auf ein Nährmedium in der Petrischale.
 Das Bakterienvolk kann sich nicht mehr Fortpflanzen, wenn keine Nahrung
 mehr zur Verfügung steht.
 Eine Nährstoffkonzentration 
\begin_inset Formula $c\left(t\right)$
\end_inset

 wird eingeführt.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{dc}{dt} & = & Zuflüsse-Abflüsse
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Je mehr Bakterien entstehen, desto schneller fällt die Konzentration.
 Die fallende Konzentration 
\begin_inset Formula $c\left(t\right)$
\end_inset

 wiederum wird als Hemmungsterm in die Wachstumsfunktion 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\frac{dN}{dt}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 aufgenommen.
 Diese Populationsfunktion 
\begin_inset Formula $N\left(t\right)$
\end_inset

 gehört zu den Logistischen Funktionen, die wiederum Teil der Sigmoidfunktionen
 ist.
 Zu Beginn wächst die Funktion beinahe exponentiell.
 Ihren Höhepunkt erreicht sie am Wendepunkt, wenn die Änderung der Population
 am grössten ist.
 Nach endlicher Zeit tritt eine Sättigung ein.
 Die Herausforderung ist aber, welche Werte 
\begin_inset Formula $N_{0},\; c_{0}$
\end_inset

 initial verwendet werden.
 Denn, wenn eine alternative Anfangsbedingung genommen wird, verändert sich
 auch die Lösung.
 Dies wird als Anfangswertproblem (AWP) bezeichnet.
 
\begin_inset CommandInset citation
LatexCommand cite
key "scst_bio"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{dc}{dt} & = & -\gamma N,\quad c\geq0\label{eq:konz_wachs}\\
\frac{dN}{dt} & = & c\left(t\right)\cdot\alpha N-\beta N^{2},\quad N\geq0\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
In diesem Abschnitt wird eine Einführung in die numerischen Lösungsverfahren
 beschrieben, die ein Modelleditor ausführt um eine approximierte Lösung
 zu erhalten.
 In unserer Simulation haben wir verschiedene numerische Verfahren implementiert
, die im Folgenden kurz vorgestellt werden.
\end_layout

\begin_layout Standard
Da sich diese Dokumentation an die Physik oder Biologie und nicht an die
 Mathematik richtet, wird keine mathematische Nomenklatur verwendet.
 So wird aus dem Zeitschritt 
\begin_inset Formula $h$
\end_inset

 der Mathematik ein 
\begin_inset Formula $\Delta t$
\end_inset

 der Physik und aus einer Ableitung 
\begin_inset Formula $y^{\prime}$
\end_inset

 der Mathematik ein 
\begin_inset Formula $\dot{y}$
\end_inset

 der Physik nach der Zeit 
\begin_inset Formula $t$
\end_inset

 oder in ausgeschriebener Form 
\begin_inset Formula $\frac{dy}{dt}$
\end_inset

 .
\end_layout

\begin_layout Subsection
Numerische Lösungsverfahren
\end_layout

\begin_layout Standard
Auch wenn das numerische Verfahren schon früh bekannt war, wurden komplexe
 Modelle erst seit der Entwicklung elektronischer Hilfsmittel numerisch
 gerechnet.
 Zuvor war der numerische Weg zu zeitaufwändig.
 Alle Rechnungen mussten von Hand durchgeführt werden.
 Komplizierte Geometrien wurden soweit vereinfacht, das sie analytisch gelöst
 werden konnten, wobei dies nicht immer möglich war.
\end_layout

\begin_layout Standard
Bei der Numerik kann eine Zahl nur als Folge von Bits dargestellt werden.
 Wenn ein Bit ändert, ändert sich die Zahl und zwischendrin gibt es eine
 Lücke.
 Das heisst, die Numerik rechnet nur eine Näherungslösung.
 Komplexe Geometrien, wie nicht lineare Differentialgleichungen, können
 nur in Ausnahmefällen analytisch gelöst werden, worauf in heutiger Zeit
 fast ausschliesslich ein numerisches Verfahren Verwendung findet.
 
\begin_inset CommandInset citation
LatexCommand cite
key "springer_kost"

\end_inset


\end_layout

\begin_layout Subsubsection
Gewöhnliche Differentialgleichungen
\end_layout

\begin_layout Standard
Eine gewöhnliche Differentialgleichung (engl.
 Ordinary Differential Equation ODE) ist eine mathematische Gleichung, die
 Ableitungen, die Funktion selbst sowie die unabhängige Variable enthalten
 kann.
 Ableitungen und die Funktion selbst treten nach genau einer unabhängigen
 Variable auf.
 Lösung 
\begin_inset Formula $y\left(t\right)$
\end_inset

 einer Differentialgleichung 
\begin_inset Formula $y^{\left(n\right)}$
\end_inset

ist eine Funktion, die mit ihren Ableitungen deckungsgleich mit der Differential
gleichung selbst ist.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y^{\left(n\right)}=f\left(t,\; y\left(t\right),\;\dot{y}\left(t\right),\;\ldots,\; y^{\left(n-1\right)}\left(t\right)\right)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Auf analytischem Weg kann eine Differentialgleichung durch unbestimmte Integrati
on erfolgen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\int y^{\left(n\right)}\cdot dt=y{}^{\left(n-1\right)}+C
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Für die computerunterstützte Berechnung von Simulationen dieser Art können
 verschiedene Techniken angewandt werden.
 Dabei gibt es grundsätzlich zwei verschiedene Vorgehen: analytisch/symbolische
 oder numerische.
 Unsere Simulation verwendet das numerische Verfahren, wie es auch Berkeley
 Madonna tut.
 Das Vorgehen beruht auf einer numerischen Approximation von gewöhnlichen
 Differentialgleichungen.
 Diese Art kann nur Differentialgleichung 1.
 Ordnung berechnen.
\end_layout

\begin_layout Standard
Eine Differentialgleichungen 2.
 Ordnung ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:odezweite"

\end_inset

 zu sehen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a=\ddot{s}\left(t\right)=-g\label{eq:odezweite}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Eine Gewöhnliche Differentialgleichung 
\begin_inset Formula $n.$
\end_inset

 Ordnung kann aber in 
\begin_inset Formula $n$
\end_inset

 Differentialgleichungen 
\begin_inset Formula $1.$
\end_inset

 Ordnung umgeformt werden.
 In den Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:zweiodeerste"

\end_inset

 wird die Differentialgleichung 
\begin_inset Formula $2.$
\end_inset

 Ordnung in zwei Differentialgleichung
\begin_inset Formula $1.$
\end_inset

 Ordnung umgewandelt.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\dot{v}\left(t\right) & = & -g\label{eq:zweiodeerste}\\
\dot{s}\left(t\right) & = & v\left(t\right)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Subsubsection
Partielle Differentialgleichungen
\end_layout

\begin_layout Standard
Eine Partielle Differentialgleichung (engl.
 Partial Differential Equation PDE) ist eine mathematische Gleichung, die
 partielle Ableitungen enthalten, also Ableitungen von Funktionen mehrere
 Variablen.
 Eine Dichte, zum Beispiel Nährboden, überdeckt eine Fläche, zum Beispiel
 eine Petrischale, im 
\begin_inset Formula $\left(x,\; y\right)=\mathbb{R}^{2}$
\end_inset

 mit einer Funktion 
\begin_inset Formula $f\left(x,\; y,\; t\right).$
\end_inset

 Ein Bakterienvolk 
\begin_inset Formula $N\left(x,\; y,\; t\right)$
\end_inset

 verändert diese Dichte über die Zeit 
\begin_inset Formula $t$
\end_inset

 aber auch bei jeder Position 
\begin_inset Formula $\left(x,\; y\right)$
\end_inset

 unterschiedlich stark.
 Bei komplexen Systemen kann es zu analytisch unlösbaren Differentialgleichungen
 führen.
 Hier hilft die Numerik weiter, die näherungsweise Lösungen ausgibt.
 Zwei wichtige numerische Verfahren sind die Finite-Differenzen-Methode
 (FDM) und die Finite-Elemente-Methode (FEM).
 
\begin_inset CommandInset citation
LatexCommand cite
key "scst_bio"

\end_inset


\end_layout

\begin_layout Standard
Die Finite-Differenzen-Methode, die für die Simulation benötigt werden,
 sind implementiert worden in das Gradienten-Verfahren und die Diffusiongleichun
g, die später erläutert werden.
 
\end_layout

\begin_layout Subsubsection
Einschrittverfahren
\end_layout

\begin_layout Standard
Zum näherungsweise Lösen von Anfangswertproblemen kann ein Einschrittverfahren
 von einem Integrationschritt 
\begin_inset Formula $t_{n}$
\end_inset

 zum Nächsten 
\begin_inset Formula $t_{n+1}$
\end_inset

 nur auf den gerade eben berechneten Wert 
\begin_inset Formula $y_{n}$
\end_inset

 zurückgreifen, wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diskrete-DGL"

\end_inset

 zu sehen ist, nicht aber auf weiter zurückliegende Werte wie 
\begin_inset Formula $y_{n-1}$
\end_inset

.
 Falls eine Reihe von zuvor berechneten Werte genutzt werden möchte, ist
 ein Mehrschrittverfahren zu wählen.
 Unterschieden wird ein Verfahren auch noch in zwei Unterformen.
 Ein 
\series bold
explizites Verfahren
\series default
 berechnet die Näherungswerte 
\begin_inset Formula $y_{n+1}$
\end_inset

 nur aus Funktionswerten 
\begin_inset Formula $f\left(t_{n},\; y_{n}\right)$
\end_inset

, die einen Schritt zurück liegen.
 Ein 
\series bold
implizites Verfahren
\series default
 bezieht auch Funktionswerte 
\begin_inset Formula $f\left(t_{n+1},\; y_{n+1}\right)$
\end_inset

 im aktuellen Schritt mit ein.
 Ein Verfahren kann 
\begin_inset Formula $s$
\end_inset

 
\series bold
Stufen
\series default
 aufweisen, die 
\begin_inset Formula $s$
\end_inset

 Funktionswerte-Berechnungen ausführt, um einen Näherungswert 
\begin_inset Formula $y_{n+1}$
\end_inset

 zu erhalten.
 Wie genau ein Verfahren rechnet, kann mit der 
\series bold
Ordnung
\series default
 
\begin_inset Formula $p$
\end_inset

 (Konsistenzordnung) ausgesagt werden.
 Genauer heisst hier mit weniger Abweichung vom exakten Wert (Fehler) pro
 Schritt, die sich über die Zeit kumulieren.
 Je genauer ein Verfahren rechnet, also je grösser die Ordnung ist, desto
 mehr Aufwand muss betrieben werden, um einen besseren Näherungswert zu
 erhalten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename dgl_diskret.pdf
	scale 50
	BoundingBox 40bp 275bp 550bp 525bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diskrete Lösung einer DGL
\begin_inset CommandInset label
LatexCommand label
name "fig:Diskrete-DGL"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Euler-Verfahren
\end_layout

\begin_layout Standard
Das Euler-Verfahren, von 
\series bold
Leonard Euler
\series default
 1768 in seinem Buch 
\shape italic
Institutiones Calculi Integralis
\shape default
 präsentiert, ist ein einfaches numerisches Verfahren, dass näherungsweise
 Lösungen einer Integration rechnet.
 Ausgangslage ist eine Differentialgleichung.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{dy}{dt} & = & f\left(t,\; y\left(t\right)\right)
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Da die Numerik mit diskreten Werten rechnet, kann eine Ableitung umgeschrieben
 werden in einen Differenzenquotient .
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{\Delta y}{\Delta t} & = & f\left(t,\; y\left(t\right)\right)\\
\Delta y & = & \Delta t\cdot f\left(t,\; y\left(t\right)\right)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Mit der Differentialgleichung und dem Anfangswert 
\begin_inset Formula $y_{0}$
\end_inset

 kann schrittweise bis zur gewünschten Endzeit numerisch Integriert werden.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
y_{n+1} & = & y_{n}+\Delta y\label{eq:euler}\\
y_{n+1} & = & y_{n}+\Delta t\cdot f\left(t_{n},\; y_{n}\right)\\
t_{n+1} & = & t_{n}+\Delta t
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Bei Differentialgleichungen 1.
 Ordnung und kleiner Schrittweite 
\begin_inset Formula $\Delta t$
\end_inset

 erhält man ausreichende Genauigkeit.
 Ab einer höheren Ordnungen büsst dieses Verfahren bei jedem Schritt an
 Genauigkeit ein.
 Es gibt bessere Verfahren, die auch Ordnungen höheren Grades mit weniger
 Genauigkeitsverlust zulassen.
\end_layout

\begin_layout Subsubsection*
Butcher Tableau
\end_layout

\begin_layout Standard
Um weitere Verfahren besser zu verstehen, wird zuerst eine Tabelle eingeführt,
 die nur als Hilfsmittel zu verwenden ist.
 Als das klassische Runge-Kutta-Verfahren entworfen wurde, kannte man diese
 Tabelle noch nicht.
 Die Tabelle wurde in den 1960er Jahren von 
\series bold
John Charles Butcher
\series default
 entwickelt für den besseren Umgang mit den nachfolgenden Runge-Kutta-Verfahren
 und nennt sich 
\shape italic
Butcher Tableau
\shape default
 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:butcher"

\end_inset

.
\end_layout

\begin_layout Standard
Wie beim Euler-Verfahren in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:euler"

\end_inset

 ergibt sich ein neuer Wert 
\begin_inset Formula $y_{n+1}$
\end_inset

 aus dem alten Wert 
\begin_inset Formula $y_{n}$
\end_inset

 addiert mit einer festen Schrittweite 
\begin_inset Formula $\Delta t$
\end_inset

 multipliziert mit der Ableitung.
 Doch beim Runge-Kutta-Verfahren werden statt einer Ableitung verschieden
 gewichtete Ableitungen 
\begin_inset Formula $b_{i}k_{i}$
\end_inset

 aufsummiert, wobei das Gewicht 
\begin_inset Formula $b_{i}$
\end_inset

 und die Ableitung 
\begin_inset Formula $k_{i}$
\end_inset

 ist.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y_{n+1}=y_{n}+\Delta t\cdot\sum_{i=1}^{s}b_{i}k_{i}\label{eq:butcher_ode}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Das 
\shape italic
Butcher Tableau
\shape default
 beinhaltet einen Variations-Vektor 
\begin_inset Formula $c$
\end_inset

, eine Matrix 
\begin_inset Formula $A=\left(a_{ij}\right)$
\end_inset

 und einen Gewichts-Vektor 
\begin_inset Formula $b$
\end_inset

 wobei 
\begin_inset Formula $i=1..s,\; j=1..s$
\end_inset

 die Zeilen- und Spalten-Indizes und 
\begin_inset Formula $s$
\end_inset

 die Dimension der Stufe ist.
 Verwendet wird nur ein Teil der Matrix 
\begin_inset Formula $A$
\end_inset

, nähmlich ein Dreieck von 
\begin_inset Formula $a_{21}$
\end_inset

 schräg herunter zu 
\begin_inset Formula $a_{s\left(s-1\right)}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\begin{array}{c|c}
c & A\\
\hline  & b^{T}
\end{array}=\begin{array}{c|cccc}
c_{1} & a_{11} & a_{12} & \dots & a_{1s}\\
c_{2} & a_{21} & a_{22} & \dots & a_{2s}\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
c_{s} & a_{s1} & a_{s2} & \dots & a_{ss}\\
\hline  & b_{1} & b_{2} & \dots & b_{s}
\end{array}\rightarrow\begin{array}{c|cccc}
0\\
c_{2} & a_{21}\\
\vdots & \vdots & \ddots\\
c_{s} & a_{s1} & \dots & a_{s\left(s-1\right)}\\
\hline  & b_{1} & b_{2} & \dots & b_{s}
\end{array}\label{eq:butcher}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Alle Gewichte 
\begin_inset Formula $b_{i}$
\end_inset

 zusammen müssen 
\begin_inset Formula $1$
\end_inset

 ergeben, sonst würde das Verfahren einen Teil der Ausgangswerte verlieren.
 Die Summe aller Gewichte ist also normiert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\sum_{i=1}^{s}b_{i}=1
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Eine Ableitung, auch Zwischenschritt oder Stützstelle genannt, ist in Gleichung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:intermstep"

\end_inset

 erläutert.
 Je grösser die Dimension der Stufe 
\begin_inset Formula $s$
\end_inset

 ist, desto mehr Zwischenschritte werden berechnet.
 Zu Beginn jedes Schrittes wird der Vektor 
\begin_inset Formula $k$
\end_inset

 zurückgesetzt auf 
\begin_inset Formula $0$
\end_inset

.
 Das heisst, beim ersten Zwischenschritt 
\begin_inset Formula $k_{1}$
\end_inset

 ist 
\begin_inset Formula $c_{1}=0,\; k_{i}=0,\; i=1,...,s$
\end_inset

 und es ergibt sich 
\begin_inset Formula $k_{1}=f\left(t_{n},\; y_{n}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
k_{i}=f\left(t_{n}+\Delta t\cdot c_{i},\; y_{n}+\Delta t\cdot\sum_{j=1}^{s}a_{ij}k_{j}\right),\; i=1,...,s\label{eq:intermstep}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Für den ersten Parameter der Funktion 
\begin_inset Formula $f\left(t\; y\left(t\right)\right)$
\end_inset

 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:intermstep"

\end_inset

 benötigen wir einen Koeffizienten 
\begin_inset Formula $c_{i}$
\end_inset

, der die unabhängige Variable 
\begin_inset Formula $t_{n}$
\end_inset

 variiert.
 Jedes 
\begin_inset Formula $c_{i},\; i=1,...,s$
\end_inset

 bildet eine Summe aller Elemente eine Zeile der Matrix 
\begin_inset Formula $A=\left(a_{ij}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
c_{i}=\sum_{j=1}^{s}a_{ij}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Ordnungsbedingung, welche Ordnung 
\begin_inset Formula $p$
\end_inset

 ein 
\shape italic
Butcher Tableau
\shape default
 besitzt, wird aus Zeitgründen aussen vorgelassen und auf die Referenz 
\begin_inset CommandInset citation
LatexCommand cite
key "oberle_ode"

\end_inset

 verwiesen.
 Jedoch kann die Ordnung 
\begin_inset Formula $p$
\end_inset

 höchstens die Stufe 
\begin_inset Formula $s$
\end_inset

 erreichen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
p\leq s
\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection*
Klassisches Runge-Kutta-Verfahren
\end_layout

\begin_layout Standard
Um eine bessere Genauigkeit zu erhalten haben 
\series bold
Carl Runge
\series default
 und 
\series bold
Martin Wilhelm Kutta
\series default
 1900, 60 Jahre vor der Präsentation des 
\shape italic
Buchter Tableaus
\shape default
, ein leistungsfähigeres Verfahren als Euler in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:euler"

\end_inset

 entwickelt, die Differentialgleichungen numerisch lösen.
 Das heisst, sie kannten die Möglichkeit einer Tabelle noch nicht.
 Nachfolgen soll jedoch der Ansatz des 
\shape italic
Buchter Tableau
\shape default
 verwendet werden.
 Dabei rechnet das Klassische vier Zwischenschritte oder Stützstellen, arbeitet
 also mit Dimension der Stufe 
\begin_inset Formula $s=4$
\end_inset

 und einer Ordnung 
\begin_inset Formula $p=4$
\end_inset

.
 Die dazugehörigen Tabelle ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rk4-table"

\end_inset

 zu finden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\begin{array}{c|c}
c & A\\
\hline  & b^{T}
\end{array} & = & \begin{array}{c|cccc}
0\\
\frac{1}{2} & \frac{1}{2}\\
\frac{1}{2} & 0 & \frac{1}{2}\\
1 & 0 & 0 & 1\\
\hline  & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6}
\end{array}\label{eq:rk4-table}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Mit 
\begin_inset Formula $s=4$
\end_inset

 werden 4 Zwischenschritte berechnet, wobei wie in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:intermstep"

\end_inset

 beschrieben 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $t_{n}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 und 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $y_{n}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 variert werden.
 Dabei beschränkt sich die Matrix 
\begin_inset Formula $A=\left(a_{ij}\right)$
\end_inset

 auf das erwähnte Dreieck, da 
\begin_inset Formula $a_{ij}=0,\; j=i..s$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
k_{1} & = & f(t_{n},\; y_{n})\\
k_{2} & = & f(t_{n}+\Delta t\cdot c_{2},\; y_{n}+\Delta t\cdot\left[a_{21}k_{1}\right])\nonumber \\
k_{3} & = & f(t_{n}+\Delta t\cdot c_{3},\; y_{n}+\Delta t\cdot\left[a_{31}k_{1}+a_{32}k_{2}\right])\nonumber \\
k_{4} & = & f(t_{n}+\Delta t\cdot c_{4},\; y_{n}+\Delta t\cdot\left[a_{41}k_{1}+a_{42}k_{2}+a_{43}k_{3}\right])\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Durch einsetzen der Werte aus der Matrix 
\begin_inset Formula $A$
\end_inset

 in die Argumente kann nochmals gekürzt werden, da auch im Dreieck noch
 Null-Werte vorhanden sind.
 
\begin_inset Formula 
\begin{eqnarray}
k_{1} & = & f(t_{n},\; y_{n})\\
k_{2} & = & f(t_{n}+\Delta t\cdot\frac{1}{2},\; y_{n}+\Delta t\cdot\frac{1}{2}\cdot k_{1})\nonumber \\
k_{3} & = & f(t_{n}+\Delta t\cdot\frac{1}{2},\; y_{n}+\Delta t\cdot\frac{1}{2}\cdot k_{2})\nonumber \\
k_{4} & = & f(t_{n}+\Delta t\cdot1,\; y_{n}+\Delta t\cdot1\cdot k_{3})\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Schlussendlich wird eine Summe gewichteter Zwischenschritte berechnet, die
 wie beim Euler-Verfahren die Funktion 
\begin_inset Formula $f\left(t,\; y\left(t\right)\right)$
\end_inset

 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:euler"

\end_inset

 übernimmt.
 Welche Gewichte genommen werden, wird in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:butcher_ode"

\end_inset

 erläutert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
y_{n+1} & = & y_{n}+\Delta t\cdot\left(\frac{1}{6}\cdot k_{1}+\frac{1}{3}\cdot k_{2}+\frac{1}{3}\cdot k_{3}+\frac{1}{6}\cdot k_{4}\right)\\
t_{n+1} & = & t_{n}+\Delta t\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Paragraph
Dormand-Prince-Verfahren
\end_layout

\begin_layout Standard
Eine noch genauere Methode wurde in den 1980er von 
\series bold
John R.
 Dormand
\series default
 und 
\series bold
Peter J.
 Prince
\series default
 entwickelt, die eine höhere Ordnung aufweise wie das Klassische Runge-Kutta-Ver
fahren.
 Diese Methode gehört zu den eingebetteten Verfahren.
 Eingebettet darum, weil es noch einen zweiten Gewichts-Vektor 
\begin_inset Formula $b_{2}$
\end_inset

 neben dem ursprünglichen Gewichts-Vektor 
\begin_inset Formula $b_{1}$
\end_inset

 besitzt.
 Die Gewichts-Vektoren sind von unterschiedlicher Ordnung.
 Das Butcher Tableu ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dorm_tableau"

\end_inset

 zu finden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\begin{array}{c|c}
\mathbf{c} & A\\
\hline  & \mathbf{b_{1}^{T}}\\
 & \mathbf{b_{2}^{T}}
\end{array} & = & \begin{array}{c|rrrrrrr}
0\\
\frac{1}{5} & \frac{1}{5}\\
\frac{3}{10} & \frac{3}{40} & \frac{9}{40}\\
\frac{4}{5} & \frac{44}{45} & -\frac{56}{15} & \frac{32}{9}\\
\frac{8}{9} & \frac{19372}{6561} & -\frac{25360}{2187} & \frac{64448}{6561} & -\frac{212}{729}\\
1 & \frac{9017}{3168} & -\frac{355}{33} & \frac{46732}{5247} & \frac{49}{176} & -\frac{5103}{18656}\\
1 & \frac{35}{384} & 0 & \frac{500}{5} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84}\\
\hline p=4 & \frac{5179}{57600} & 0 & \frac{7571}{16695} & \frac{393}{640} & -\frac{92097}{339200} & \frac{187}{2100} & \frac{1}{40}\\
p=5 & \frac{35}{384} & 0 & \frac{500}{1113} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84} & 0
\end{array}\label{eq:dorm_tableau}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Zuerst rechnet man wie beim klassischen Runge-Kutta-Verfahren 
\begin_inset Formula $k_{i}$
\end_inset

 wie in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:intermstep"

\end_inset

 aus, jedoch nur 
\begin_inset Formula $i=1..\left(s-1\right)$
\end_inset

.
 Die letzte Stufe 
\begin_inset Formula $i=7$
\end_inset

 eines Schrittes ist gleichzeitig die erste Stufe des nächsten Schrittes.
 Das Berechnen der Näherungswert ist in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dopri_value"

\end_inset

 zu sehen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
z_{n+1} & = & y_{n}+\Delta t\cdot\sum_{i=1}^{s}b_{2{}_{i}}k_{i}\label{eq:dopri_value}\\
y_{n+1} & = & y_{n}+\Delta t\cdot\sum_{i=1}^{s}b_{1{}_{i}}k_{i}\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Die Differenz 
\begin_inset Formula $\left|z_{n+1}-y_{n+1}\right|$
\end_inset

 zwischen dem Näherungswert 5.
 Ordnung 
\begin_inset Formula $z_{n+1}$
\end_inset

 und dem Näherungswert 4.
 Ordnung 
\begin_inset Formula $y_{n+1}$
\end_inset

 ergibt die Fehlertoleranz 
\begin_inset Formula $\epsilon$
\end_inset

.
 Wenn die Toleranz 
\begin_inset Formula $\epsilon$
\end_inset

 zu gross wird, wird so lange die Schrittweite 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\Delta t$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 erniedrigt, bis der Fehler 
\begin_inset Formula $\left|z_{n+1}-y_{n+1}\right|$
\end_inset

 wieder in der Toleranz 
\begin_inset Formula $\epsilon$
\end_inset

 liegt.
 Eine optimale Schrittweite 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\Delta t_{opt}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 wird in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dopri_optstep"

\end_inset

 gezeigt.
 Dieses Verfahren hat demzufolge eine Schrittweitensteuerung.
 
\begin_inset CommandInset citation
LatexCommand cite
key "teubner_hanke,dankert_ode"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\Delta t_{opt} & = & \Delta t\cdot\left(\frac{\epsilon\cdot\Delta t}{2\cdot\left|z_{n+1}-y_{n+1}\right|}\right)^{\frac{1}{5}}\label{eq:dopri_optstep}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Die (AB)² Simulation besitzt zwar im Flow-Modell-Editor eine Möglichkeit,
 die Simulation mit der Dormand-Prince-Methode auszuführen, ist aber noch
 nicht ausreichen getestet worden.
\end_layout

\begin_layout Subsubsection
Diffusionsgleichung
\end_layout

\begin_layout Standard

\color red
Weiten wir das Beispiel in der Gleichung ...
 aus.
 
\end_layout

\begin_layout Standard
Ein Beispiel aus der Natur soll eines von vielen Anwendungsgebieten aufzeigen.
 Eine Zelle ist von einer Zellmembran umschlossen, die die Zelle schützt.
 Die Zelle kann aber durch ihre teildurchlässige Membran Nährstoffe aufnehmen
 oder abstossen.
 Der Stoffaustausch ist ein Diffusionsprozess.
 Ein Diffusionsprozess versucht Konzentrationsunterschiede auszugleichen,
 bis ein Gleichgewicht hergestellt ist.
\end_layout

\begin_layout Standard
Die Diffusionsgleichung umschreibt eine einfache Diffusion und ist in Gleichung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:diffusion"

\end_inset

 in analytischer Form zu sehen, wobei 
\begin_inset Formula $D$
\end_inset

 der Diffusionskoeffizient, 
\begin_inset Formula $\Delta f$
\end_inset

 der Laplace-Operator über die Funktion 
\begin_inset Formula $f$
\end_inset

 und 
\begin_inset Formula $d$
\end_inset

 die Dimension ist.
 In der Fläche wird eine Dimension 
\begin_inset Formula $d=2$
\end_inset

 verwendet.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\Delta & = & \sum_{i=1}^{d}\frac{\partial^{2}}{\partial r_{i}^{2}}\label{eq:diffusion}\\
\frac{\partial}{\partial t}f\left(\vec{r},\; t\right) & = & D\cdot\Delta f\left(\vec{r},\; t\right)\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Für die (AB)² Simulation diskretisiert sich die Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:diffusion"

\end_inset

 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:diffusion_num"

\end_inset

.
 Dabei bedient man sich der Finite-Differenzen-Methode (FDM).
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diskrete-Faltung"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Maske-Diffusion"

\end_inset

 kann die Gleichung nochmals nachverfolgt werden, wobei das Ursprungsbild
 
\begin_inset Formula $u_{n}$
\end_inset

 und das Zielbild 
\begin_inset Formula $\Delta u$
\end_inset

 ist.
 Das Symbol 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\Delta$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang german-ch
 wird hier als Different verstanden.
 Der Punkt 
\begin_inset Formula $\left(x,\; y\right)$
\end_inset

 liegt in der Mitte der Maske.
 Die Maske geht über das ganze Bild.
 In der Simulation wird die Diffusion in einer Matrize gelöst.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\Delta u & = & f\left(x,\; y+1\right)+f\left(x,\; y-1\right)+f\left(x+1,\; y\right)+f\left(x-1,\; y\right)-4\cdot f\left(x,\; y\right)\label{eq:diffusion_num}\\
u_{n+1} & = & u_{n}+\Delta t\cdot D\cdot\Delta u\nonumber 
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Filterung mit Maske.pdf
	BoundingBox 40bp 610bp 400bp 820bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diskrete Faltung
\begin_inset CommandInset label
LatexCommand label
name "fig:Diskrete-Faltung"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Maske Diffusion.pdf
	scale 75
	BoundingBox 40bp 400bp 200bp 570bp
	clip

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Maske für eine diskrete Diffusion
\begin_inset CommandInset label
LatexCommand label
name "fig:Maske-Diffusion"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gradienten-Verfahren
\end_layout

\begin_layout Standard
Eine Zelle braucht Nahrung um zu überleben.
 Sie fühlt sich am sichersten, wenn Nahrung im Überfluss vorhanden ist.
 Wenn um sie herum mehr Nahrung auf einen potentiellen Konsumenten wartet
 als die Position, in der die Zelle sich momentan befinden, versucht sie
 ihre Position zu ändern.
\end_layout

\begin_layout Standard
Ein einfaches Verfahren in der Numerik um ein lokales Maximum eines Skalarfeldes
 zu finden, ist das Gradienten-Verfahren.
 Dabei befindet man sich an einer Position 
\begin_inset Formula $\vec{r}$
\end_inset

 im Skalarfeld.
 Mit dem Nabla-Operator 
\begin_inset Formula $\nabla$
\end_inset

 wird eine Gradient-Operation auf das Skalarfeld angewendet, dass ein Vektorfeld
 als Resultat hat.
 Im Vektorfeld, an der gleichen Position wie im Skalarfeld, befindet sich
 ein Verschiebungs-Vektor, der anzeigt, in welcher Richtung das lokale Maximum
 ist.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\vec{r}_{n+1} & = & \vec{r}_{n}+\Delta t\cdot\nabla f\left(\vec{r}_{n}\right)
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
In der (AB)² Simulation ist der Raum nur eine Fläche.
 Das hier implementierte Gradienten-Verfahren ist eine Finite-Differenzen-Method
e (FDM).
 Um die neue Position 
\begin_inset Formula $\left(x_{n+1},\; y_{n+1}\right)$
\end_inset

zu bestimmen, braucht es die aktuelle Position 
\begin_inset Formula $\left(x_{n},\; y_{n}\right)$
\end_inset

, die Differenzen 
\begin_inset Formula $\left(\Delta x,\;\Delta y\right)$
\end_inset

 und den Zeitschritt 
\begin_inset Formula $\Delta t$
\end_inset

.
 Zur Berechnung der Differenzen kann eine diskrete Faltung in Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Diskrete-Faltung"

\end_inset

 mit einer Maske in 
\begin_inset Formula $x$
\end_inset

-Richtung und in 
\begin_inset Formula $y$
\end_inset

-Richtung wie in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Maske-Gradient"

\end_inset

 benutzt werden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\Delta x & = & f\left(x+1,\; y\right)-f\left(x,\; y\right)\\
\Delta y & = & f\left(x,\; y+1\right)-f\left(x,\; y\right)\\
x_{n+1} & = & x_{n}+\Delta t\cdot\Delta x\\
y_{n+1} & = & y_{n}+\Delta t\cdot\Delta y
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Maske Gradient.pdf
	scale 75
	BoundingBox 70bp 400bp 330bp 550bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Maske für einen diskreten Gradienten
\begin_inset CommandInset label
LatexCommand label
name "fig:Maske-Gradient"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Methode
\end_layout

\begin_layout Subsection
Graphische Darstellung der Modelle
\end_layout

\begin_layout Standard
Die Modelle werden mit einem graphischen Editor abgebildet.
 Dazu gibt es zwei Modelle, das Flow-Modell, welches Flüsse abbildet.
 Dies ist auch das Innere der Meso-Kompartimente, welche sich auf dem XY-Modell
 an einer Position (X/Y) befinden.
 Im XY-Modell können zusätzlich Dichten definiert werden.
 Eine Dichte verhält sich in unserer Simulation wie ein digitalisiertes
 Bild, jeder Pixel ist ein Topf, der eine bestimmte Menge Stoff enthält.
 Dieser Stoff kann von den Meso-Kompartimente konsumiert bzw.
 produziert werden, wodurch sich das 
\begin_inset Quotes eld
\end_inset

Bild
\begin_inset Quotes erd
\end_inset

 während der Simulation ändert.
 Ebenso können sich die Meso-Kompartimente anhand der Dichten bewegen, je
 nach 
\begin_inset Quotes eld
\end_inset

Vorliebe
\begin_inset Quotes erd
\end_inset

/Dichte zu den Maximas oder zu den Minimas.
 Die Dichte diffundiert während der Simulation, um wieder die Analogie mit
 dem Bild herzustellen bedeutet das in etwa das gleich, wie wenn auf ein
 Bild ein Grauscher Weichzeichner angewendet wird.
 Dies bedeutet, dass wenn die Simulation unendlich laufen würde, und keine
 Meso-Kompartments vorhanden sind, die etwas verändern, so wird die Dichte
 irgendwann überall gleich hoch sein.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/model-uebersicht.eps
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/model-uebersicht-legende.eps
	width 8cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Schematische Darstellung des Simulationseditors
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Werkzeuge des Simulationstools sehen dann effektiv so aus wie in den
 folgenden Abbildungen.
 Es sind nicht alle Kombinationen von Verbindungen gezeigt, grundsätzlich
 sind Parameterverbindungen zu allen anderen Objekten möglich.
 Flüsse sind nur zwischen (Density)Containern möglich.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Meso-Kompartment.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Meso-Kompartimente, hier klar zu erkennen das Fragezeichen, welches einen
 Fehler signalisiert.
 Die Farbe kennzeichnet das darunterliegende Flussmodell.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Parameter.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Parameter, können Berechnungen und Konstanten enthalten.
 Fehler werden durch Fragezeichen gekennzeichnet, mithilfe des blauen Pfeils
 können Verbindungen erstellt werden
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Parameter verbunden.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Zwei verbundene Parameter: «var1» kann und muss den Wert von «var2» verwenden.
 Wird der Wert nicht verwendet erscheint ein Fehler (Fragezeichen) wird
 der Wert nicht verbunden und trotzdem verwendet erscheint ebenfalls ein
 Fehler.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Global.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Globale, funktioniert gleich wie der Parameter, ist jedoch überall Global
 verfügbar, auch ohne Verbindung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Globale_Abhaengigkeit1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Globale_Abhaengigkeit2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Verbindung von und zu Globalen wird mit Schatten dargestellt, somit
 ist sichtbar, wo die Globalen verwendet werden, bzw.
 ob ein Objekt eine Globale verwendet.
 Der Schatten wird angezeigt sobald ein Element selektiert ist.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Container.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Container: enthalten eine Formel für den Initialwert und können Ein-/Ausflüsse
 enthalten.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/parts/Fluss.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Flüsse: Sind nur möglich zwischen Containern und ins Unendliche
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Werkzeuge und Hilfsmittel
\end_layout

\begin_layout Subsubsection
Programmiersprachen & Entwicklungsumgebung
\end_layout

\begin_layout Standard
Die Vorgabe bestand unter anderem in einem GUI, welches plattformunabhängig
 funktionieren sollte.
 Daher haben wir uns für Java entschieden.
 Java ist dank der Java Virtual Machine komplett plattformunabhängig, und
 bietet mit Swing ein Framework für GUI Applikationen.
\end_layout

\begin_layout Standard
Die eigentliche Simulation wird mit Plugins realisiert, daher beschränkt
 sich die Auswahl der Programmiersprache nur auf den Editor.
 Ein Plugin kann in einer beliebigen Sprache geschrieben werden, es muss
 lediglich eine Java Klasse geschrieben werden, die dieses Plugin lädt.
 Das laden einer Library aus Java ist z.B.
 mit JNI (Java Native Interface) möglich.
 Die Argumente für/gegen eine Sprache gelten aber grundsätzlich auch für
 die Simulation, abgesehen vom GUI Framework, das für die Simulation nicht
 benötigt wird.
\end_layout

\begin_layout Standard
Alternative plattformunabhängigen Programmiersprachen mit Vor- und Nachteilen:
\end_layout

\begin_layout Itemize
C/C++ (Weiter C++ genannt)
\end_layout

\begin_deeper
\begin_layout Itemize
Positiv
\end_layout

\begin_deeper
\begin_layout Itemize
Da C++ eine hardwarenahe Sprache ist, könnten Hardwarebeschleunigungen wie
 z.B.
 MMX bei Intel Prozessoren genutzt werden.
 Dies muss jedoch von Hand vorgenommen werden, und es ist zu beachten, dass
 diese Optimierungen für jede Prozessorarchitektur (z.B.
 Intel 32 bit, Intel 64 bit, ARM) separat vorgenommen werden müsste.
\end_layout

\end_deeper
\begin_layout Itemize
Negativ
\end_layout

\begin_deeper
\begin_layout Itemize
C++ Beinhaltet keine GUI Bibliotheken, je nach Plattform kommen verschiedene
 Frameworks wie MFC (Windows), Cocoa (Mac OS X), GTK/QT (Linux) zum Einsatz.
 Die Framerworks GTK und QT sind jedoch auch Plattformunabhängig einsetzbar,
 und lassen sich auch unter Mac OS X/Windows einsetzen, dies ist jedoch
 mit einem höheren Aufwand verbunden als z.B.
 bei Java mit Swing.
\end_layout

\begin_layout Itemize
Die Applikation müsste für jedes Betriebssystem/jede CPU Architektur neu
 übersetzt werden.
 Unterschiede wie z.B.
 Little-/Big-Endian müssen bei der Entwicklung berücksichtigt werden, ansonsten
 können Fehler auftreten.
\end_layout

\begin_layout Itemize
Das Programmieren ist aufwändiger, da in C++ Prototypen in Headerfiles deklarier
t werden müssen, diese müssen in korrekter Reihenfolge inkludiert werden
 etc.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
.NET
\end_layout

\begin_deeper
\begin_layout Itemize
Positiv
\end_layout

\begin_deeper
\begin_layout Itemize
Die .NET Umgebung von Microsoft läuft wie Java ebenfalls in einer VM, beinhaltet
 eine GUI Library und ist vom Syntax Java ähnlich
\end_layout

\end_deeper
\begin_layout Itemize
Negativ
\end_layout

\begin_deeper
\begin_layout Itemize
Microsoft bietet nur eine VM für Windows an, es existiert zwar Mono als
 VM für Linux, Mac OS X ist jedoch schlecht unterstützt.
 Mono unterstützt nicht alle GUI Elemente die von Microsoft unterstützt
 werden.
\end_layout

\begin_layout Itemize
Die Kompatibilität verschiedener .NET Versionen (z.B.
 2.0 und 4.0) ist wesentlich schlechter als bei Java.
 Bei Java lässt sich auch Code der für eine ältere Version geschrieben wurde
 kompilieren, was bei .NET oftmals nicht der Fall ist.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Skriptsprachen wie Python, Ruby etc.
\end_layout

\begin_deeper
\begin_layout Itemize
Positiv
\end_layout

\begin_deeper
\begin_layout Itemize
Einfache & flexible Entwicklung
\end_layout

\begin_layout Itemize
Kein Kompilieren notwendig
\end_layout

\end_deeper
\begin_layout Itemize
Negativ
\end_layout

\begin_deeper
\begin_layout Itemize
Grundsätzlich langsamer als Java (Python/Ruby können auch zu Java Bytecode
 kompiliert werden, dann fällt dieser Punkt weg, wir gehen aber von der
 Standard Runtime aus)
\end_layout

\begin_layout Itemize
Wie bei C++ keine Standard GUI Library, es muss ebenfalls auf GTK/QT zurückgegri
ffen werden
\end_layout

\begin_layout Itemize
Das Fehlerhandling ist schwerer, da bei Skriptsprachen oftmals Fehler erst
 zur Laufzeit festgestellt werden.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Java ist für den Benutzer die einfachste Lösung, da er nur die JVM installiert
 haben muss, es gibt keine weiteren Abhängigkeiten wie z.B.
 bei Skriptsprachen wie Python, welches zusätzlich noch GTK benötigen würde.
\end_layout

\begin_layout Standard
Java optimiert beim starten der Applikation automatisch auf die vorhandene
 Hardware, dies hat zwar einen langsameren Start zur Folge, optimiert aber
 im allgemeinen besser als dies ein Programmierer machen würde.
 Wenn in einer Sprache wie z.B.
 in C++ manuell optimiert wird, wird immer auf eine bestimmte Hardware optimiert
, z.B.
 Intel x86 32 bit Prozessoren.
 Wird der gleiche, optimierte Code auf 64 bit Prozessoren ausgeführt so
 ist dieser nicht mehr optimal.
 Wird dieser Code nun für einen ARM Prozessor kompiliert, so wird die manuelle
 Optimierung sich wahrscheinlich sogar negativ auswirken.
 ARM Prozessoren werden immer häufiger verbaut, unter anderem auch in Subnoteboo
ks.
\end_layout

\begin_layout Standard
Als Entwicklungsumgebung kamen sowohl Eclipse als auch IntelyJ zum Einsatz,
 für beide IDEs sind Projektfiles vorhanden.
 Es kam JDK 1.6 (Java 6) zum Einsatz, JDK 1.7 (Java 7) ist noch nicht soweit
 verbreitet, und würde der Applikationen keine Vorteil bringen.
\end_layout

\begin_layout Subsubsection
Markup Language
\end_layout

\begin_layout Standard
Als Markup Language für die Simulation kam der Matlab Syntax zum Einsatz,
 der ebenfalls vom Open Source Tool «octave» verarbeitet werden kann.
 Somit ist es möglich die Simulation ausserhalb der Applikation laufen zu
 lassen, in einer Umgebung, die mathematische Funktionen anbietet, die uns
 intern nicht zur Verfügung stehen, bzw.
 die wir selbst hätten schreiben müssen.
 Zudem ist es möglich, dass der generierte Code noch angepasst werden kann
 vor der Simulation.
\end_layout

\begin_layout Subsubsection
Plugin Handling
\end_layout

\begin_layout Standard
Die Applikation hat einige Punkte, die sinnvollerweise durch Plugins erweitert
 werden können.
 Es gibt bereits fertige Frameworks, die Pluginhandlings ermöglichen, eines
 der bekannten ist Eclipse mit dem OSGi.
 Dieses basiert auf Extension Points und Extensions, welche wieder Extension
 Pointes bereitstellen können.
 Ein Extension Point ist eine 
\begin_inset Quotes eld
\end_inset

Andockstelle
\begin_inset Quotes erd
\end_inset

 für die Extensions, es können (grunsätzlich) beliebig viele Plugins 
\begin_inset Quotes eld
\end_inset

andocken
\begin_inset Quotes erd
\end_inset

.
 Die komplette Applikation wird dann als Plugin aufgebaut, Abhängigkeiten
 können spezifiziert werden und Seiteneffekte können vermieden werden durch
 die Abschottung einzelner Plugins gegeneinander.
 Sogar das mehrfache Laden einer Library in verschiedenen Versionen ist
 ohne Probleme möglich.
 Für unsere Applikation ist soviel Flexibilität aber nicht nötige, zudem
 würde dies auch einen hohen Mehraufwand bei der Implementation bedeutet.
 Unsere Pluginimplementation funktioniert daher viel einfacher:
\end_layout

\begin_layout Enumerate
Es wird ein Interface für ein Plugin definiert, dies geschieht in der Hauptappli
kation
\end_layout

\begin_layout Enumerate
Ein Plugin implementiert diese Schnittstelle.
 Zudem wird ein XML File erstellt, indem steht
\end_layout

\begin_deeper
\begin_layout Enumerate
Der Name des Plugins
\end_layout

\begin_layout Enumerate
Eine Beschreibung
\end_layout

\begin_layout Enumerate
Der Autor
\end_layout

\begin_layout Enumerate
Die Klasse, die geladen werden soll beim Start des Plugins
\end_layout

\end_deeper
\begin_layout Enumerate
Der Javacode und das XML File werden in ein .jar gepackt und in einem vordefinier
ten Ordner abgelegt (meist konfigurierbar in «config.properties»)
\end_layout

\begin_layout Enumerate
Die Applikation durchsucht beim Start diesen Ordner, öffnet alle .jar Dateien
 und lädt das plugin.xml File.
 Hat dies alles geklappt, wird das Jarfile in den aktuellen Kontext geladen
 und die Klasse ausgeführt
\end_layout

\begin_layout Enumerate
Es gibt keine Querabhängigkeiten, das Plugin wird direkt in den Applikationkonte
xt geladen, und hat vollen Zugriff auf die Applikation
\end_layout

\begin_layout Standard
Es sind momentan zwei Pluginschnittstellen vorhanden
\end_layout

\begin_layout Enumerate
Laden von Fremdformate: Plugins für Berkeley Madonna und Dynasys sind vorhanden,
 siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Fremdformat-importe"

\end_inset


\end_layout

\begin_layout Enumerate
Simulation: Plugins für Interne Simulation und Matlab Codegeneration: 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Vorhandene-Simulationplugins"

\end_inset


\end_layout

\begin_layout Subsubsection
Vorhandene Simulationplugins
\begin_inset CommandInset label
LatexCommand label
name "sub:Vorhandene-Simulationplugins"

\end_inset


\end_layout

\begin_layout Standard
Es sind bereits zwei Plugins vorhanden, eines das alles intern simuliert,
 und eines das Matlab Code generiert und diesen ausführt.
\end_layout

\begin_layout Itemize
Internes Plugin
\end_layout

\begin_deeper
\begin_layout Itemize
Kann nur Flow Modelle Simulieren
\end_layout

\begin_layout Itemize
Simulationsverfahren: Euler Verfahren, Runge Kutta 4
\end_layout

\begin_layout Itemize
Funktionsweise: Es wird alles mit dem intern vorhandenen JEP Parser gerechnet
\end_layout

\end_deeper
\begin_layout Itemize
Matlab Plugin
\end_layout

\begin_deeper
\begin_layout Itemize
Kann Flow und XY Modelle Simulieren
\end_layout

\begin_layout Itemize
Simulationsverfahren: 
\end_layout

\begin_deeper
\begin_layout Itemize
Für Flow-Modell: Euler, Runge-Kutta 4.
 Nicht ausführlich getestet: Fehlberg, Cash-Karp, Dormand-Prince
\end_layout

\begin_layout Itemize
Für XY-Modell: Runge Kutta 4
\end_layout

\end_deeper
\begin_layout Itemize
Funktionsweise: Beim JEP Parser, der bei jeder Eingabe im GUI eine Verifikation
 vornimmt und bei einer fehlerhaften Formel einen Fehler ausgibt, werden
 alle Formeln zuerst aufbereitet und in Matlab Code herausgeschrieben.
 Matlab wird gestartet und der Matlab Code wird ausführt.
 Falls der zuvor generierte Code keine Fehler hat, werden pro Resultat eine
 Text-Datei erstellt, die dann nach beenden von Matlab in der Simulation
 geladen und dargestellt werden.
 Bei fehlerhaftem Code bricht Matlab die Ausführung ab, beendet sich aber
 nicht.
 Der Prozess muss dann manuell beendet werden.
\end_layout

\end_deeper
\begin_layout Subsubsection
Dateiformat
\end_layout

\begin_layout Standard
Als Dateiformat wird ein eigens entwickeltes, auf XML basierendes Dateiformat
 verwendet.
 Dieses Dateiformat spiegelt die Internen Strukturen ziemlich genau ab.
 Zudem gibt es Plugin Schnittstelle um Fremdformate zu importieren, es ist
 somit möglich, beliebige Fremdformate zu importieren.
 Es muss dafür lediglich ein Plugin erstellt und im richtigen Verzeichnis
 abgelegt werden.
\end_layout

\begin_layout Paragraph
Fremdformat-importe
\begin_inset CommandInset label
LatexCommand label
name "par:Fremdformat-importe"

\end_inset


\end_layout

\begin_layout Standard
Es wurden zwei Importplugins erstellt, eins für Berkeley Madonna, und eins
 für Dynasys.
 Um einen sinnvollen Test der Pluginschnittstelle vorzunehmen waren zwei
 Plugins notwendig.
\end_layout

\begin_layout Standard
Dynasys ist seit 2009 unter der GPL freigegeben, somit war ein Einblick
 in den Pascal Code möglich.
 Die Pascal Objekte wurden binär serialisiert, und da es sich bei Dynasys
 noch um eine 16bit Applikation handelt, konnte der Code nicht kompiliert
 werden zur Analyse (keine entsprechender Compiler vorhanden).
 Daher werden nicht alle Daten korrekt eingelesen.
 Trotz Einschränkungen ist es somit möglich, kleinere Dateien komplett und
 grössere Dateien teilweise einzulesen.
\end_layout

\begin_layout Standard
Bei Berkeley Madonna war kein Quellcode verfügbar, jedoch basiert der grafische
 Modellierungsteil von Berkeley Madonna auf Java.
 Die Datei an sich ist binär, enthält jedoch die Magic Bytes 0xACED, welches
 von Java als Start für eine Object Stream verwendet werden.
 Der Stream enthält nur primitive Datentypen und Objekte aus der Java Runtime,
 es müssen also keine spezifischen Klassen vorhanden sein.
 Mit Beispieldateien war es möglich, das Format zu reverse engineeren.
 Es wird nicht alles korrekt importiert, es konnten jedoch die aus der Physikvor
lesung vorhandenen Dateien korrekt importiert werden.
\end_layout

\begin_layout Standard
Die Nächste Version von Berkeley Madonna, Version 9, verwendet nun aber
 ein neues, XML basierendes Format, welches nicht implementiert wurde.
 Es könnte jedoch auch dieses Format mit einem zusätzlichen Plugin eingelesen
 werden.
\end_layout

\begin_layout Standard
Wie das binäre Serialisierungsprotokoll von Java aufgebaut ist, kann unter
 http://docs.oracle.com/javase/6/docs/platform/serialization/spec/protocol.html
 nachgelesen werden.
\end_layout

\begin_layout Paragraph*
Internes Dateiformat
\end_layout

\begin_layout Standard
Die von (AB)² Simulation erstellen Dateien enden auf .simz, es handelt sich
 dabei um ein standard ZIP-File, welches 4 Files enthält:
\end_layout

\begin_layout Itemize
configuration.xml
\end_layout

\begin_layout Itemize
mimetype
\end_layout

\begin_layout Itemize
simulation.xml
\end_layout

\begin_layout Itemize
version
\end_layout

\begin_layout Standard
Die Datei «version» ist ein Java Property File, mit zwei Einträgen, beides
 Integer.
\end_layout

\begin_layout Quote
version=1
\end_layout

\begin_layout Quote
compatible=1
\end_layout

\begin_layout Standard
Der Eintrag «version=» ist die Version des Dateiformates.
 Der Eintrag «compatible=» ist die Version des Dateiformates zu der diese
 Datei abwärtskompatibel ist, also immer noch eingelesen werden kann, ohne
 das grössere Probleme auftreten.
 Wird eine Inkompatible Änderung am Dateiformat vorgenommen, so müssen beide
 Versionsnummern um eins hochgezählt werden, wird eine kompatible Erweiterung
 am Dateiformat vorgenommen, so wird lediglich «version=» hochgezählt.
\end_layout

\begin_layout Standard
«mimetype» ist ein Textfile mit einem einzigen String, «application/zhaw.simulati
on.project».
 Diese Datei wird oft verwendet, um den Typ eines auf ZIP-basierenden Dateiforma
ts zu erkennen.
 Zum Beispiel verwendet .odt als mimetype «application/vnd.oasis.opendocument.text»,
 dank solchen Kennungen kann Zipfile eindeutig als gültiges Simulationsfile
 erkennen.
\end_layout

\begin_layout Standard
configuration.xml enthält die Konfiguration der Plugins, z.B.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=XML,caption=configuration.xml, language=html]
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<simconfig>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.dt" value="0.1"/>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.end" value="5.0"/>
\end_layout

\begin_layout Plain Layout

    <double name="simulation.start" value="0.0"/>
\end_layout

\begin_layout Plain Layout

</simconfig>
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Einstellungen können von den Plugins beliebig festgelegt werden, hier
 sind nur Einstellungen gespeichert, und keine Business Daten.
\end_layout

\begin_layout Standard
simulation.xml enthält das Modell, oder bei einem XY-Model auch mehrere Modelle.
 Diese Datei sieht folgendermassen aus (gekürzt, kommentiert):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=XML,caption=simulation.xml, language=html]
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

    <model grid="20" height="400" type="xy" width="400" zerox="200" zeroy="200">
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="grad(&quot;d1&quot;,
 &quot;x&quot;)" directiony="1" name="m0" value="model3" x="151" y="89"/>
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="sin(1/2)" directiony="co
s(1/2)" name="m1" value="model3" x="10" y="88"/>
\end_layout

\begin_layout Plain Layout

        <meso derivative="FIRST_DERIVATIVE" directionx="1" directiony="1"
 name="m5" value="model2" x="256" y="281"/>
\end_layout

\begin_layout Plain Layout

        <global name="g0" value="5" x="252" y="37"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        <density name="d1" text="" value="10*sin(x/20)+10*cos(y/20)"/>
\end_layout

\begin_layout Plain Layout

        <density name="d2" text="" value="x"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       <model name="model2" type="flow">
\end_layout

\begin_layout Plain Layout

            <container name="Q" value="0" x="262" y="109"/>
\end_layout

\begin_layout Plain Layout

            <parameter name="UC" value="Q/C" x="220" y="238"/>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

           <!-- Fluss, <helperpoint> sind die Bezier Hilfspunkte -->
\end_layout

\begin_layout Plain Layout

           <flowConnector name="I" value="UR/R">
\end_layout

\begin_layout Plain Layout

                <source>
\end_layout

\begin_layout Plain Layout

                    <helperpoint x="116" y="147"/>
\end_layout

\begin_layout Plain Layout

                    <infinite x="34" y="116"/>
\end_layout

\begin_layout Plain Layout

                </source>
\end_layout

\begin_layout Plain Layout

                <target to="Q">
\end_layout

\begin_layout Plain Layout

                    <helperpoint x="230" y="145"/>
\end_layout

\begin_layout Plain Layout

                </target>
\end_layout

\begin_layout Plain Layout

                <valve x="140" y="118"/>
\end_layout

\begin_layout Plain Layout

            </flowConnector>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            <!-- Parameter Verbindung -->
\end_layout

\begin_layout Plain Layout

            <connector from="Q" to="UC">
\end_layout

\begin_layout Plain Layout

                <helperpoint x="256" y="207"/>
\end_layout

\begin_layout Plain Layout

            </connector>
\end_layout

\begin_layout Plain Layout

        </model>
\end_layout

\begin_layout Plain Layout

        <model name="model3" type="flow">
\end_layout

\begin_layout Plain Layout

            <!-- Anderes Submodel...
 -->
\end_layout

\begin_layout Plain Layout

        </model>
\end_layout

\begin_layout Plain Layout

    </model>
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Dateiformat ist weitgehend selbsterklärend.
 Es wurde erstellt, um das Modell unserer Applikation möglichst genau abzubilden.
 Es wurde nicht angestrebt, einen Standard zu erschaffen/mit anderen Applikation
en über dieses Format zu interagieren.
\end_layout

\begin_layout Standard
Grundsätzlich gilt: jeder XML Tag entspricht einem Objekt, jedes Attribut
 eines Tags entspricht einem Attribut eines Objekts (einfaches Attribut
 wie ein String).
 Jeder Tag innerhalb eines anderen Tags entspricht einem Attribut eines
 Objekts (komplexes Attribut, z.B.
 Punkt mit zwei Koordinaten).
 Somit entspricht das Format nicht ganz den XML Richtlinien, welches alle
 relevanten Informationen als Tags und alle Metainformationen als Attribute
 abspeichert, ist aber dem Code sehr nahe und auch einfach zu verstehen.
\end_layout

\begin_layout Section
Vorgehen
\end_layout

\begin_layout Subsection
Softwarearchitektur
\end_layout

\begin_layout Subsubsection
Projektunterteilung
\end_layout

\begin_layout Standard
Die Applikation besteht aus mehreren Javaprojekten, die hier in einer Übersicht
 kurz beschrieben werden
\end_layout

\begin_layout Enumerate

\series bold
AppDefinition:
\series default
 Dieses Projekt beinhaltet Interfaces der Applikation, die nicht im Projekt
 «Simulation» untergebracht werden konnten, da ansonsten eine zyklische
 Abhängigkeit entstanden wäre
\end_layout

\begin_layout Enumerate

\series bold
BJavalibs:
\series default
 Generelle Java GUI Libraries von Andreas Butti, dieser Code ist grösstenteils
 vor der BA entstanden
\end_layout

\begin_layout Enumerate

\series bold
Editor:
\series default
 Abstrakter Editor für XY- und Flow Modelle.
 Beinhaltet alle basis Klassen, Globale Parameter, Clipboard, Undo/Redo,
 Toolbar/Menubar und den Formeleditor
\end_layout

\begin_layout Enumerate

\series bold
Editor.Flow:
\series default
 Der Editor für Flussdiagramme, basierend auf «Editor»
\end_layout

\begin_layout Enumerate

\series bold
Editor.XY:
\series default
 Der Editor für XY-Diagramme, basierend auf «Editor»
\end_layout

\begin_layout Enumerate

\series bold
ExternLibraries:
\series default
 Dies ist nur ein Pseudoprojekt, und beinhaltet kein Code.
 Hier sind unsere externen Libraries untergebracht.
\end_layout

\begin_deeper
\begin_layout Enumerate
JFreeChart: Diagramm Library
\end_layout

\begin_layout Enumerate
JCommon: Wird von JFreeChart benötigt
\end_layout

\begin_layout Enumerate
JXLayer: Wird verwendet um beim Simulieren den Editor Unscharf darzustellen
 und ein Statusdialog direkt im Editor darzustellen
\end_layout

\begin_layout Enumerate
SwingX: Erweiterte Swing GUI-Komponenten, werden an diversen Stellen benötigt
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
ImageExport:
\series default
 Der «Speichern als Bild» Dialog
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter:
\series default
 Definition für Importplugins
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter.Dynasys:
\series default
 Dynsys Import Plugin
\end_layout

\begin_layout Enumerate

\series bold
ImportFilter.Madonna:
\series default
 Berkeley Madonna Import Plugin
\end_layout

\begin_layout Enumerate

\series bold
Model:
\series default
 Das «Domänenmodell», dies ist die interne Abbildung aller Daten, die modelliert
 werden können.
\end_layout

\begin_layout Enumerate

\series bold
NetbeansDirchooser:
\series default
 Dieser Code entstammt dem Netbeans Projekt, es ermöglicht die komfortable
 auswahl eines Ordners, die mit Swing Boardmittel wesentlich weniger konfortabel
 wäre: Es können die Ordner wie gewohnt als Baum ausgeklappt werden.
\end_layout

\begin_layout Enumerate

\series bold
OnscreenKeyboard:
\series default
 Hierbei handelt es sich um die Tastatur für die Spezialzeichen, die bei
 Feldern im Diagramm zur Verfügung steht.
\end_layout

\begin_layout Enumerate

\series bold
Plugin:
\series default
 Dies ist die Implementation um Plugins zu laden.
 Diese 285 Zeilen Code stammen aus einem vorgängigen Projekt von Andreas
 Butti
\end_layout

\begin_layout Enumerate

\series bold
Simulation:
\series default
 Dies ist der Einsprungpunkt der Applikation.
 Hier befinden sich auch die globalen Komponenten
\end_layout

\begin_deeper
\begin_layout Enumerate
About Dialog
\end_layout

\begin_layout Enumerate
Einstellungen
\end_layout

\begin_layout Enumerate
Speichern/Laden
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
SimulationBuild:
\series default
 Dies ist ein Pseudoprojekt, das nur für den Build der Applikation benötigt
 wird, es enthält kein Code
\end_layout

\begin_layout Enumerate

\series bold
SimulationDiagram:
\series default
 Dieses Projekt enthält die Darstellung eines Diagramms, obwohl das eigentliche
 Diagramm von JFreeChart dargestellt wird gibt es einiges um das Diagramm,
 wie die Legende oder die Konfiguration, welche in diesem Projekt zu finden
 sind
\end_layout

\begin_layout Enumerate

\series bold
SimulationJepLib-2.4.1:
\series default
 JEP ist ein Open Source Parser, welcher für die Interne Simulation und
 das Prüfen von Formeln eingesetzt wird.
 Da das Projekt offiziell nicht mehr supported wird, wurde der Sourcecode
 komplett kopiert, um kleine Fehlerkorrekturen vorzunehmen.
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin:
\series default
 Die Definition des Simulationplugins
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin.Intern:
\series default
 Interne Simulation, die Formeln werden mit JEP berechnet.
 Das Plugin unterstützt nur das Flow-Modell, das XY-Modell ist nicht implementie
rt.
 Es wird nur Runge-Kutta und Euler unterstützt.
\end_layout

\begin_layout Enumerate

\series bold
SimulationPlugin.MatlabOctave:
\series default
 Dieses Plugin generiert den Matlab Markup.
 Ohne dieses Plugin ist die Simulation von XY-Modellen nicht möglich.
\end_layout

\begin_layout Enumerate

\series bold
SimulationSidebar:
\series default
 Hier befinden sich Definitionen für die Sidebar der Applikation, diese
 mussten in ein eigenes Projekt ausgelagert werden, um keine zyklischen
 Abhängigkeiten zu produzieren, gehören jedoch eigentlich zum Editor.
\end_layout

\begin_layout Enumerate

\series bold
Sysintegration:
\series default
 Hier werden die Plattform/Systemabhängigen Komponenten abgelegt, dies beinhalte
t unter anderem
\end_layout

\begin_deeper
\begin_layout Enumerate
Alle Icons (bei der aktuellen Implementation wird jedoch nicht nach Plattform
 unterschieden).
 Siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Einfügen-neuer-Icons"

\end_inset


\end_layout

\begin_layout Enumerate
Bookmark Implementationen (z.B.
 die Auswahl «Desktop» beim Speichern eines Bildes stammt von hier)
\end_layout

\begin_layout Enumerate
Toolbar Implementation: Die von Swing bereitgestellte Toolbar sieht auf
 Mac OS X komisch aus, daher hier eine angepasste Version.
 Zudem enthält diese Implementation einige für die Simulation zugeschnittene
 Anpassungen.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
VectorExport:
\series default
 Hier enthalten ist die Library Freehep und einige Helferklassen.
 Mithilfe dieses Projektes werden beim Bilderexport SVG, EMF und EPS Dateien
 erzeugt.
\end_layout

\begin_layout Enumerate

\series bold
XYResultViewer:
\series default
 Bei diesem Projekt handelt es sich um das «Diagramm» von XY-Simulationen.
 Es kann die Bewegungen und die Dichten darstellen.
 Im Gegensatz zur Darstellung von Flow-Simulationen müssen hier 3 Dimensionale
 Daten dargestellt werden.
 Die dritte Dimension ist hier die Zeit und wird durch einen Slider dargestellt.
\end_layout

\begin_layout Standard
Die Aufteilung in 25 Projekte erscheint auf den ersten Blick etwas unübersichtli
ch, auf den zweiten Blick entsprechen die meisten Projekte aber einzelnen
 Komponenten der Applikation, die auch in der Applikation entsprechend aufgeteil
t sind und machen daher Sinn.
 Lediglich 2 Projekte wurden aus technischen Gründen (zyklische Abhängigkeiten)
 erstellt und entsprechen keinen eigenen Komponenten.
\end_layout

\begin_layout Subsubsection
Design Pattern
\end_layout

\begin_layout Standard
Die Applikation wurde nach MVC (Model View Control) bzw.
 Domänenmodell aufgebaut.
 Das bedeutet, dass die Daten, die Logik und der View nur lose gekoppelt
 sind, und somit auch der View ersetzt werden könnte, ohne das der Rest
 angepasst werden müsste.
 Diese beiden Design Pattern beschreiben ein ziemlich ähnliches vorgehen,
 wobei MVC sich hauptsächlich auf einen GUI Komponenten beziehen lässt,
 wie z.B.
 ein TreeView, während das Domänenmodell sich auf eine komplette Applikation
 anwenden lässt.
 Beides sind Vorgehensmuster und keine exakten Vorgaben.
\end_layout

\begin_layout Standard
Das (Domänen)Modell befindet sich im Projekt «Model» und ist entsprechend
 von allem anderen entkoppelt.
 Die Simulation ist nur vom Model abhängig, und es besteht keine direkte
 Verbindung zur GUI.
 Die GUI selbst ist ein relativ grosser Teil der Applikation und ist auch
 nicht überall klar abgegrenzt.
\end_layout

\begin_layout Standard
Komponeten wie Undo/Redo sind bei uns komplett in der GUI untergebracht,
 da diese auch komplett von dieser abhängig sind.
 Designtechnisch ist die Einordnung solcher Komponenten nicht eindeutig,
 denn z.B.
 Undo/Redo enthält ein Modell, nämlich die letzten Änderungen.
 Es enthält zudem Logik, es kann Änderungen Rückgängig machen/Wiederherstellen.
 Es ist aber ein GUI Komponent, denn es ist 100% von der GUI abhängig.
 Wenn wir jedoch definieren, dass es sich bei den Undo/Redo Daten nicht
 um Business Daten, sondern um Metadaten handelt sollte es auch nach den
 Pattern kein Problem sein, wenn wir es innerhalb der GUI unterbringen.
 Zudem war dies die einzige technisch sinnvolle Möglichkeit.
\end_layout

\begin_layout Subsection
Technische Beschreibung Softwarekomponenten
\end_layout

\begin_layout Subsubsection
Model
\end_layout

\begin_layout Standard
Das Datenmodell ist folgendermassen aufgebaut: Der Einsprungpunkt ist das
 «SimulationDocument», welches entweder ein «SimulationFlowModel» oder ein
 «SimulationXYModel» beinhaltet.
 Sowohl das Flow als auch das XY Modell erben von , «AbstractSimulationModel»,
 dieses beinhaltet «AbstractSimulationData», welches ebenfalls eine Abstrakte
 Klasse für alle Simulationskomponenten darstellt, wie
\end_layout

\begin_layout Itemize
Container
\end_layout

\begin_layout Itemize
Parameter
\end_layout

\begin_layout Itemize
Global
\end_layout

\begin_layout Itemize
Meso Kompartment.
\end_layout

\begin_layout Standard
«SimulationFlowModel» enthält zusätzlich noch Verbindungen, welche entweder
 ein Fluss oder eine Parameterverbidung darstellen.
 Abgebildet werden diese als «AbstractConnectorData<?>».
 Wobei der Fluss «FlowConnectorData» und der «ParameterConnectorData» die
 beiden möglichen Implementationen darstellen.
\end_layout

\begin_layout Standard
«SimulationXYModel» enthält zusätzlich zur Basisklasse noch Dichten, welche
 von der Klasse «DensityData» sind, hier besteht keine Abstraktion, es gibt
 nur eine Implementation.
\end_layout

\begin_layout Standard
Zudem kann ein XY Model beliebig viele Flow Modelle enthalten, welche über
 «SubModelList» gehandelt werden.
\end_layout

\begin_layout Standard
Die Modelle enthalten jede Menge an Methoden zur Manipulation der Daten,
 welche hier nicht aufgeführt werden, diese können der Codedokumentation
 oder dem Code entnommen werden.
\end_layout

\begin_layout Subsubsection
Editor
\end_layout

\begin_layout Standard
Der Editor ist einer der komplexeren Elemente dieser Applikation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/Vererbung Editor.eps
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Übersicht Editoraufbau
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Editor besteht aus mehreren Komponenten, grob aufgelistet in der Grafik.
 Der eigentliche Editor Component ist eine Ableitung von «AbstractEditorView»,
 entweder «FlowEditorView» oder «XYEditorView».
 Diese Komponenten haben ein paar Eigenheiten.
 Die Methode paint ist überschrieben, und beim Zeichen werden alle Aktionen
 selbst koordiniert.
 Dies ist notwendig, um Pfeile, die selbst kein JComponent sind, korrekt
 abzubilden.
 Pfeile können nicht als JComponent abgebildet werden, da ein JComponent
 immer rechteckig ist, und unsere Pfeile dies im Normalfall nicht sind.
 Bei der Darstellung ist dies noch kein Problem, aber der Pfeil würde dann
 auf der gesamten Fläche auch alle Mouse-Events konsumieren, diese müssten
 dann weitergeleitet werden wenn nötig etc.
 Darum haben wir für die Pfeile eine Architektur gewählt, die die Swing
 Architektur bricht, da wir eine Darstellung gewählt haben, die unüblich
 ist und daher von Swing so nicht unterstützt wird.
\end_layout

\begin_layout Standard
Auch die Selektion wird nach dem Zeichnen aller Komponenten einfach überzeichnet.
 Es gibt zudem die Möglichkeit, dass Komponenten einen Schatten zeichnen.
 Dies wird angewendet, um Abhängigkeiten von/zu Globalen darzustellen.
 Wird eine Globale angewählt, werden alle abhängigen Elemente mit einem
 Schatten versehen.
\end_layout

\begin_layout Standard
Als Layoutmanager kommt «SimulationLayout» zum Einsatz, welches alle «AbstractDa
taView<?>» korrekt platziert.
 Alle anderen Komponenten werden nicht umplatziert.
 Dies bedeutet, wenn etwas anderes angezeigt wird, muss dieses manuell mit
 «setBounds» platziert werden, was auch verwendet wird z.B.
 beim blauen Verbindungspfeil.
 Dieser erscheint wenn ein Objekt selektiert wird.
\end_layout

\begin_layout Standard
Die Clipboard Implementierung ist architekturbedingt in mehrere Klassen
 aufgeteilt, unterstützt unter anderem das Kopieren als Rastergrafik.
 Das Exportieren als Vektorgrafik konnte nicht erfolgreich implementiert
 werden, da dies je nach Betriebssystem anders gehandhabt wird, und damit
 es z.B.
 unter Windows zuverlässig funktioniert muss eine Vektorgrafik (EMF/WMF)
 eingebettet in einem RTF exportiert werden, während unter Linux eher ein
 SVG direkt in die Zwischenablage kopiert wird.
 Alle Simulationsinternen Datenstrukturen werden in die Datenstruktur «TransferD
ata» abgefüllt.
 Zudem werden alle Objekte mit IDs versehen, damit nach dem Einfügen die
 Pfeile wieder verbunden werden können.
\end_layout

\begin_layout Standard
Der Bilderexport gestaltet sich relativ einfach, dank der verwendeten «freehep»
 Library wird einfach mit dem Graphics von «freehep» «paint» aufgerufen,
 den eigentlichen Export übernimmt die Library.
\end_layout

\begin_layout Standard
Undo/Redo war und ist einer der umständlichen Teile der Implementation,
 denn es muss für jede Aktion, die der User vornimmt, manuell eine Implementatio
n vorgenommen werden, die diese Aktion auch wieder Rückgängig machen kann.
 Dies ist auch beim Erweitern der Applikation zu bedenken, denn wenn dies
 vergessen geht, ist die Konsistenz nicht mehr gewährleistet, was zu Fehlern
 führt.
 Für das Debugging des Undo/Redo Mechanismus musste daher eine kleine Hilfe
 implementiert werden.
 Wird die Applikation mit dem Parameter 
\begin_inset Quotes eld
\end_inset

--debug-undo
\begin_inset Quotes erd
\end_inset

 aufgerufen erscheint ein Dialog, der alle Aktionen des aktuellen Undo/Redo
 Handlers live auflistete und je nach Status einfärbt.
 Zu bedenken ist, dass nach dem erstellen einer neuen Datei ein neuer Undo/Redo
 Handler erstellt wird, und der Dialog daher nicht mehr funktioniert.
\end_layout

\begin_layout Subsubsection
Errorhandling/Logging
\end_layout

\begin_layout Standard
Bei Serverapplikationen ist es üblich, dass alle Aktionen geloggt werden,
 bei GUI Applikationen ist es weniger üblich, daher haben wir uns entschieden,
 nur die Fehler zu loggen.
 Andere Ausgaben werden direkt auf STDOUT geschrieben, und sind somit nur
 lesbar wenn dieser entweder umgeleitet oder die (AB)² Simulation direkt
 auf einer Konsole gestartet wird.
 Dies ist jedoch nur bei der Entwicklung sinnvoll.
 Alle Meldungen, die für den Benutzer relevant sind, werden als Popups ausgegebe
n.
\end_layout

\begin_layout Standard
Ein wichtiger Punkt, der oft vergessen geht, ist, dass die Exceptions im
 Eventloop auch abgefangen werden müssen.
 Dies geschieht mit 
\begin_inset Quotes eld
\end_inset

Errorhandler.registerAwtErrorHandler();
\begin_inset Quotes erd
\end_inset

 somit wird unserer eigener Errohandler als Eventloop errorhandler registriert,
 und kann somit alle Fehler, die nicht gecatcht sind und im Eventloop auftreten,
 abfangen, dem User anzeigen und loggen.
\end_layout

\begin_layout Standard
Fehler, die zu erwarten sind, werden in unserer Applikation abgefangen,
 und dem Benutzer eine Entsprechende Meldung angezeigt.
 Zu erwartende Fehler sind z.B.
 ungültige Benutzereingaben, nicht genügend Schreibrechte oder Fehler bei
 Formeln wie log(-1).
 Unerwartete Fehler sind z.B.
 IOException aufgrund eines kaputten Datenträgers, manipulierte Simulationsdatei
en etc.
\end_layout

\begin_layout Standard
Alle zu erwartenden Fehler werden den Benutzer mit «Messagebox.showError»
 dargestellt, während unerwartete Fehler mit «Errorhandler.showError(e, <optional
e Beschreibung>);» dargestellt und automatisch geloggt werden.
 Der Pfad für das Logging wird in der Konfigurationsdatei festgelegt.
\end_layout

\begin_layout Subsubsection
GUI Konsistenz
\end_layout

\begin_layout Standard
Es wurde viel Wert darauf gelegt, das die GUI konsistent erscheint.
 Dabei wurde das Benutzerhandling an Linux/OS X angelehnt.
\end_layout

\begin_layout Itemize
Konfigurationsdialoge wie die Einstellungen/Formeldialog/Diagrammeinstellungen
 enthalten keine 
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Übernehmen
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Abbrechen
\begin_inset Quotes erd
\end_inset

 Buttons, sondern alle Änderungen werden sofort übernommen.
 (Teilweise werden die Änderungen auch erst beim Schliessen des Dialoges
 gespeichert, was aber für den User irrelevant ist).
\end_layout

\begin_layout Itemize
Jegliche Messageboxen werden von der Klasse «Messagebox» dargestellt, welche
 den Defaultbutton grösser, fett und immer ganz rechts darstellt.
 
\end_layout

\begin_layout Itemize
Alle Layouts werden mit Layoutmanager gelayoutet, dies bedeutet wenn ein
 Benutzer z.B.
 eine grössere Schrift hat ist dies kein Problem, es können alle Dialoge
 vergrössert werden und der Inhalt wird auch vergrössert.
 Einzige Ausnahme ist der Editor: Das Simulationdokument wird nicht 
\begin_inset Quotes eld
\end_inset

gezoomt
\begin_inset Quotes erd
\end_inset

, wenn der Editor vergrössert wird.
\end_layout

\begin_layout Itemize
Es wird nur die nötige Konfiguration angeboten: Nur die Einstellungen die
 auf jedem System verschieden sind/Von externen Parametern abhängig sind,
 werden angeboten.
 Globale sind grün und Parameter gelb.
 Es macht keinen Sinn, solche Dinge konfigurierbar zu machen.
 Das verwirrt die Benutzer höchstens.
\end_layout

\begin_layout Itemize
Es werden keine 
\begin_inset Quotes eld
\end_inset

Sind Sie sicher?
\begin_inset Quotes erd
\end_inset

 Meldungen angezeigt.
 Es können aber alle Aktionen, die das Dokument verändern, rückgängig gemacht
 werden (solange der Editor offen bleibt).
 Somit sind solche Nachfragen nicht nötig/sinnvoll.
\end_layout

\begin_layout Itemize
Fehler bei der Datenvalidierung werden grafisch hervorgehoben, oder es ist
 erst gar nicht möglich, ungültige Werte einzugeben.
\end_layout

\begin_layout Subsubsection
Konfiguration/Einstellungen (Backend)
\end_layout

\begin_layout Standard
Beim Start der Applikation wird eine Datei ./config/config.properties eingelesen.
 Diese Datei muss existieren, ansonsten werde Fehler auftreten.
 In dieser Datei sind alle konfigurierbaren Einstellungen gespeichert, die
 der Benutzer aber nicht umstellen soll/muss/kann.
 Diese sind:
\end_layout

\begin_layout Itemize
portable=[true | false]: Wenn portable = true ist die Applikation Portabel,
 es werden alle Einstellungen relativ zur Applikation gespeichert.
 Ist die Einstellung 
\begin_inset Quotes eld
\end_inset

false
\begin_inset Quotes erd
\end_inset

, werden alle Einstellungen im betriebsystemspezifischen Ordner abgelegt
 (es gibt keine Registry Einträge unter Windows)
\end_layout

\begin_deeper
\begin_layout Itemize
Linux: ~/.config
\end_layout

\begin_layout Itemize
Mac ~/Library
\end_layout

\begin_layout Itemize
Windows 
\begin_inset Quotes eld
\end_inset

C:
\backslash
Users
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

C:
\backslash
Document and Settings
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
errorlogPath=errorlog/: Der Pfad wo Fehlermeldungen abgelegt werden (ggf.
 relativ zur, je nach «portable»)
\end_layout

\begin_layout Itemize
settingsPath=config/: Der Pfad für die Einstellungen (ggf.
 relativ zur, je nach «portable»)
\end_layout

\begin_layout Itemize
importPluginFolder=plugin/import/: Immer relativ zur App, wo die .jar's oder
 .xml's gesucht werden um die Plugins zu laden, hier die Importplugins für
 Fremdformate.
\end_layout

\begin_layout Itemize
simulationPluginFolder=plugin/simulation/: Siehe oben; Hier die Plugins
 zur Simulation
\end_layout

\begin_layout Itemize
predefinedDash: Die Liniendefinitionen für das Diagram.
 Getrennt mit Semikolon (;).
 Durchgezogene Linie: 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

 (leerer String, wobei in der Konfiguration keine Anführungszeichen angegeben
 werden.), 5 Punkte gestrichelte Linie: 
\begin_inset Quotes eld
\end_inset

5 5
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
defaultsFonts: Eine mit Semikolon (;) getrennte Liste von Schriftnamen.
 Die erste Schrift, welche auf dem System installiert ist wird verwendet
 für die Diagramme.
\begin_inset Newline newline
\end_inset

Dies wird benötigt um eine passende, installierte Schrift zu finden, denn
 wird eine Java Schrift wie 
\begin_inset Quotes eld
\end_inset

Sans
\begin_inset Quotes erd
\end_inset

 verwendet, so wird dieser Name auf eine installierte Schrift gemappt.
 Dieses Mapping kann zu Inkonsistenzen bei der JFreeChart Schriftenkonfiguration
 führen.
\end_layout

\begin_layout Itemize
keyboard...: Definition des Sonderzeichen On-Screen-Keyboard wird verwendet,
 um bei den Diagrammen in den Namen Sonderzeichen einzugeben.
 Parameter definieren das Aussehen der Tastatur und werden hier nicht alle
 im Detail erläutert.
 Die Zeichen, die angezeigt werden, sind hier definiert.
 Man beachte die Unicodeschreibweise (wird z.B.
 von Eclipse automatisch escaped): keyboard.keys=
\backslash
u03B1;
\backslash
u03B2;
\backslash
u03B3;...
\end_layout

\begin_layout Standard
Im Settingsordner werden mehre Dateien abgelegt, alle Einstellungen die
 von der Applikation und den Plugins definiert werden, sind in der Datei
 
\begin_inset Quotes eld
\end_inset

settings.ini
\begin_inset Quotes erd
\end_inset

 abgelegt.
 Es ist nicht vorgesehen, dass die Datei von Hand editiert wird.
 Sollten Probleme mit den Einstellungen auftreten, kann die Datei einfach
 gelöscht werden, es werden dann die Defaulteinstellungen verwendet.
\end_layout

\begin_layout Standard
Die Dateien endend auf 
\begin_inset Quotes eld
\end_inset

.windowPos
\begin_inset Quotes erd
\end_inset

, speichern die Position der Fenster, um nach dem nächsten Start der Applikation
 alle Fenster wieder an der gleichen Position anzuzeigen.
\end_layout

\begin_layout Standard
Dies kann zu Problemen führen, z.B.
 wenn die Bildschirmkonfiguration verändert wurde/Beamer an/abgesteckt wurde.
 Um solche Probleme zu lösen, können einfach alle Dateien endend auf 
\begin_inset Quotes eld
\end_inset

.windowPos
\begin_inset Quotes erd
\end_inset

 gelöscht werden, dann werden beim nächsten Start alle Fenster auf dem Hauptbild
schirm zentriert angezeigt.
\end_layout

\begin_layout Subsubsection
Matlab Code Generator
\end_layout

\begin_layout Standard
Eines der Simulations-Plugins ist das Matlab Plugin.
 Dieses Plugin generiert ausführbaren Matlab-Code.
 Dabei wird zwischen dem reinen Flow-Modell und dem XY-Modell mit integriertem
 Flow-Modell pro Meso-Kompartiment unterschieden.
 Beim Flow-Modell können verschiedene Simulationsverfahren ausgewählt werden.
 Beim XY-Modell kann nur das Runge-Kutta-4-Verfahren gewählt werden.
\end_layout

\begin_layout Standard
Zur kompakten Berechnung und für die Übergabe als Argument wird ein Vektor
 verwendet, der alle aktuellen Container-Werte beinhaltet.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Flow Modell Algorithmus.pdf
	BoundingBox 30bp 130bp 280bp 560bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Folgenden Dateien werden pro Simulationsverfahren generiert:
\end_layout

\begin_layout Itemize
Flow-Modell:
\end_layout

\begin_deeper
\begin_layout Itemize
Euler:
\family typewriter
 simulation_euler.m
\end_layout

\begin_layout Itemize
Runge-Kutta 4: 
\family typewriter
simulation_rk_main.m, simulation_rk_ode.m
\end_layout

\begin_layout Itemize
Fehlberg, Cash-Karp, Dormand-Prince: 
\family typewriter
simulation_adaptive.m, simulation_adaptive_ode.m
\end_layout

\end_deeper
\begin_layout Itemize
XY-Modell:
\end_layout

\begin_deeper
\begin_layout Itemize
Runge-Kutta 4: 
\family typewriter
xy_main.m, sim_gradient.m, sim_diffusion.m, sim_density_out.m, xy_
\shape italic
densityN
\shape default
_function, xy_
\shape italic
modelN
\shape default
_dy.m
\end_layout

\end_deeper
\begin_layout Section
Resultate
\end_layout

\begin_layout Standard
Test der Matheengine, Vergleich mit Berkeley-Madonna
\end_layout

\begin_layout Standard
Ergebnisse
\end_layout

\begin_layout Standard
Beschreibung, Screenshots, Beispielsimulationen mit Ergebniss-Diagramm
\end_layout

\begin_layout Subsection
Numerische Lösungsverfahren
\end_layout

\begin_layout Subsubsection
Diffusionsgleichung
\end_layout

\begin_layout Standard
Um die Implementierung der numerischen Diffusionsgleichung zu testen, soll
 eine Funktion gefunden werden, die am Anfang und am Ende der Diffusion
 mit anderen Methoden nachgeprüft werden kann.
 Die Dichtefunktion als der Wahrscheinlichkeitstheorie erfüllt diese Voraussetzu
ngen.
 Die Lösung der Dichtefunktion erhält die Grössen, die eine weitere Voraussetzun
g für die Prüfung der Diffusionsgleichung ist.
 Allgemein ist die Dichtefunktion normiert auf 
\begin_inset Formula $\int G=1$
\end_inset

, hat ihr Maximum im Null-Punkt und besitzt einen Vektor 
\begin_inset Formula $\vec{r}$
\end_inset

, der die Position eines Punkte festlegt, die Zeit 
\begin_inset Formula $t$
\end_inset

, einen konstanten Diffusionskoeffizient 
\begin_inset Formula $D$
\end_inset

 und eine konstante Dimension 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
G\left(\vec{r},\; t\right) & = & \frac{1}{\left(4\pi Dt\right)^{\frac{d}{2}}}\cdot e^{-\left(\frac{\vec{r}^{2}}{4Dt}\right)}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Die (AB)² Simulation arbeitet im XY-Modell nur in Dimension 
\begin_inset Formula $d=2$
\end_inset

, stellt also eine Fläche dar, und hat demzufolge einen Vektor 
\begin_inset Formula $\vec{r}=\left(x,\; y\right)$
\end_inset

.
 Die Fläche besitzt normalerweise zwischen 
\begin_inset Formula $10^{2}$
\end_inset

 bis 
\begin_inset Formula $10^{3}$
\end_inset

 Punkte pro Richtung.
 Da die Dichtefunktion normiert ist und über eine grosse Fläche führt, würde
 ein Wert einer Zelle sehr klein werden und für die Auswertung eventuell
 zu Problemen führen.
 Darum wird ein Faktor dazumultipliziert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
G\left(x,\; y,\; t\right) & = & 1000\cdot\frac{1}{4\pi Dt}\cdot e^{-\left(\frac{x^{2}+y^{2}}{4Dt}\right)}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Zu Beginn wird die Matrix im XY-Modell auf eine Dichtefunktion initialisiert,
 wobei Diffusionskoeffizient 
\begin_inset Formula $D$
\end_inset

 und Zeit 
\begin_inset Formula $t$
\end_inset

 bekannt sein müssen.
 Eine Zeit 
\begin_inset Formula $t=0$
\end_inset

 würde zu einer Division durch Null führen und eine Zeit um 
\begin_inset Formula $t=0$
\end_inset

 herum gäbe eine sehr steile Verteilung.
 Für dieses Beispiel wird eine Initial-Zeit 
\begin_inset Formula $t=50$
\end_inset

 und ein Diffusionskoeffizient 
\begin_inset Formula $D=0.3$
\end_inset

 gewählt.
 Die normiert Funktion 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Greensche Funktion.pdf
	scale 50
	BoundingBox 50bp 140bp 800bp 450bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gradienten-Verfahren
\end_layout

\begin_layout Standard
Das Verfahren kann überschiessen.
\end_layout

\begin_layout Section
Diskussion und Ausblick
\end_layout

\begin_layout Subsection
Markup Language
\end_layout

\begin_layout Standard
Wir haben uns die Matlab Markup Language entschieden, da wir auf viele vordefini
erten Funktionen (
\begin_inset Quotes eld
\end_inset

Toolbox
\begin_inset Quotes erd
\end_inset

) zurückgreifen konnten, und uns somit den mathematischen Teil teilweise
 vereinfachen.
\end_layout

\begin_layout Standard
Es haben sich jedoch immer wieder Probleme mit den in Matlab vordefinierten
 Funktionen ergeben, grundsätzlich erfüllen die Funktionen unsere Anforderungen.
 Dies haben wir auch vorgängig abgeklärt, jedoch sind bei der Verwendung
 Probleme aufgetreten, die die Verwendung der Toolboxfunktionen verunmöglichten:
\end_layout

\begin_layout Itemize
Numerische Integration: Es kann zwar ein Integral numerisch integriert werden,
 jedoch müssen wir mehrere Integrale Simultan lösen, was von der Matlab
 Toolbox nicht unterstützt wird
\end_layout

\begin_layout Itemize
Gradienten berechnen mit 
\begin_inset Quotes eld
\end_inset

grad
\begin_inset Quotes erd
\end_inset

: Wird ein Gradienten im diskreten Raum berechnet, so tritt immer das Problem
 auf, dass die Zahlen in einem Gitter abgelegt werden müssen, was mathematisch
 natürlich falsch ist.
 Matlab versucht den mathematischen Fehler gleichmässig auf alle Richtungen
 zu verteilen.
 Dies bedeutet, dass wenn eine Spitze abgeleitet wird, ein Plateu entsteht.
 Diese Plateus sind für unsere Simulation extrem ungünstig.
 Daher haben wir jetzt einen Gradienten implementiert der einfach um 0.5
 Einheiten im Raster verschoben ist.
 Dies bewirkt zwar ein Abdriften in eine Richtung, dies stört aber die Simulatio
n weniger als ein Plateu.
 Ein Plateu kann bewirken, dass sich ein Meso-Kompartment, welches sich
 zur niedrigsten Konzentration bewegen soll, nicht mehr bewegt.
\end_layout

\begin_layout Standard
Wir erstellen nun den kompletten Matlab Code selbst, es werden keine Toolboxen
 verwendet.
 Nach dem Erstellen eines temporären Files wird ein neuer Matlab/Octave
 Prozess erstellt, und dieser führt die Simulation aus.
\end_layout

\begin_layout Standard
Leider hat sich das Fehlerhandling viel schwieriger gestaltet als erwartet,
 denn z.B.
 Matlab beendet sich nicht nach einem Fehler mit einem entsprechenden Exit
 Code, sondern geht in den Interaktiven Modus über.
\end_layout

\begin_layout Standard
Zudem ist die Plattformunabhängigkeit nicht gewährleistet, denn es muss
 für jede Plattform separat getestet werden, was wir auch gemacht haben
 und festgestellt haben das es nicht auf allen Plattformen funktioniert.
\end_layout

\begin_layout Standard
Wir haben nun festgestellt, dass der Weg mit einer Markup Language, insbesondere
 Matlab/Octave schwierig ist:
\end_layout

\begin_layout Itemize
Fehlerhandling schwierig
\end_layout

\begin_layout Itemize
Plattformunabhängigkeit funktioniert nur bedingt
\end_layout

\begin_layout Itemize
Keine programmiertechnischen Vorteile (zumindest nicht mit Matlab/Octave)
\end_layout

\begin_layout Itemize
Geschwindigkeitseinbussen: bei kleinen Simulationen fällt insbesondere der
 Start einer externen Applikation stark ins Gewicht.
 Octave ist zudem generell langsamer als Matlab.
 Ein analysierter Fall hat ergeben, dass eine Simulation, die in Matlab
 nur wenige Minuten gedauert hat, mit Octave hochgerechnet 16 Stunden dauern
 würde.
\end_layout

\begin_layout Standard
Wir haben daher entschieden, dass eine zukünftige Entwicklung nicht auf
 dieser Basis, sondern der Code komplett intern ausgeführt wird.
 Daher haben wir auch keine Zeit mehr ins Fehlerhandling/Plattformunabhängigkeit
 etc.
 investiert.
 Eine Interne Simulation bringt zusätzlich folgende Vorteile:
\end_layout

\begin_layout Itemize
Eine Formel, die bei der Eingabe vom Parser validiert wurde, ist auch zu
 100%ig sicher ausführbar.
 Wenn eine Formel mit dem internen Parser validiert wurde und dann als Matlab
 Code ausgegeben wird ist dies nicht sicher, denn die Parser unterscheiden
 sich in Details, die unter Umständen nicht alle korrekt gehändelt werden.
 Zudem wird jede Formel beim internen Parser in einem separaten Kontext
 ausgeführt, was bei Matlab nicht der Fall ist.
 Somit können unter ungünstigen Umständen Seiteneffekte auftreten, welche
 beim internen Parser praktisch ausgeschlossen sind.
\end_layout

\begin_layout Itemize
Fehler sind immer gehändelt, und können normalerweise ihrem Ursprungsobjekt
 zugeordnet werden (z.B.
 einem Container).
 Wenn im Matlab Code ein Fehler auftritt, kann dieser nur einer Zeile zugeordnet
 werden,.
 Es ist jedoch für den Anwender nicht offensichtlich, wo der Ursprung des
 Fehlers liegt.
\end_layout

\begin_layout Itemize
Die Simulation kann einfach abgebrochen werden: Wenn die externe Simulation
 abgebrochen werden muss ist dies wesentlich komplizierter, und funktioniert
 ggf.
 nicht unter allen Umständen.
\end_layout

\begin_layout Itemize
Parallelisierung: Heutzutage besitzt jeder moderne PC mehr als einen Rechenkern.
 Mit Matlab/Octave ist es jedoch nicht möglich, dies zu nutzen.
 Bei einer internen Simulation wäre dies möglich, wenn auch aufwendig.
 Somit könnte die Simulation grösserer Modelle um Faktoren beschleunigt
 werden.
 (Voraussetzung: mehr als ein Core, und das Modell muss entsprechend unabhängige
 Teile aufweisen.
 Ein Aufteilen eines einzelnen Integrals ist theoretisch zwar möglich, praktisch
 ist es jedoch langsamer als die Simulation auf einem CPU, da die Synchronisatio
n sehr viel Leistung benötigt)
\end_layout

\begin_layout Standard
Um die Vorteile einer Markuplanguage wirklich auszunutzen, müssten Tools
 zum Einsatz kommen, die aufgrund der Lizenzkosten nicht generell zur Verfügung
 stehen.
 Ob diese bezüglich den oben genannten Punkten besser zu handhaben sind,
 wurde nicht geprüft.
\end_layout

\begin_layout Subsection*
TODO
\end_layout

\begin_layout Standard
Was Fehlt noch, was muss noch gemacht werden? Interpretation und Validierung
 der Resultate Rückblick auf Aufgabenstellung, erreicht bzw.
 nicht erreicht Legt dar, wie an die Resultate (konkret vom Industriepartner
 oder weiteren Forschungsarbeiten; allgemein) angeschlossen werden kann;
 legt dar, welche Chancen die Resultate bieten 18.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand
\backslash
refname{
\backslash
section{Literaturverzeichnis}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "din1505/alphadin"

\end_inset


\end_layout

\begin_layout Part
Anhang
\end_layout

\begin_layout Section
Codeanmerkungen
\end_layout

\begin_layout Standard
Der Javacode wurde mit Tabulatoren eingerückt, welche auf 4 Leerzeichen
 eingestellt sind.
 Das Encoding der Dateien ist UTF-8.
 Wird das Encoding falsch eingestellt, können Sonderzeichen und Umlaute
 nicht mehr dargestellt werden.
\end_layout

\begin_layout Section
Glossar
\end_layout

\begin_layout Standard
Meso-Kompartment: Ein Teil des XY-Simulationsmodells
\end_layout

\begin_layout Standard
Swing: Java GUI Framework
\end_layout

\begin_layout Section
Weiterentwicklung
\end_layout

\begin_layout Standard
Hier wird anhand von Beispielen beschrieben, wie die Applikation weiterentwickel
t werden kann.
 Die Beispiele an sich erfüllen nur den Zweck der Illustration.
 Die Anleitung bezieht sich auf Eclipse unter Linux, es ist jedoch nicht
 relevant welche IDE das verwendet wird.
 Java Kenntnisse sind erforderlich.
 Es wird davon ausgegangen, dass alle Projekte der Simulation bereits importiert
 wurden und fehlerfrei kompilieren (Innerhalb der IDE, Ant ist für diese
 Beispiele nicht erforderlich, da Eclipse, InteliJ, Netbeans und alle modernen
 IDEs automatisch den Javacode kompilieren).
\end_layout

\begin_layout Subsection
Verwendete Tools/Libraries
\end_layout

\begin_layout Itemize
Runtime
\end_layout

\begin_deeper
\begin_layout Itemize
Java Version: 1.6/6 (Java 1.6 ist die interne Versionsnummer, Java 6 ist die
 Marketingbezeichnung)
\end_layout

\end_deeper
\begin_layout Itemize
Entwicklungsumgebung
\end_layout

\begin_deeper
\begin_layout Itemize
Eclipse: 3.7.1
\end_layout

\begin_layout Itemize
IntelliJ: 11.1.1
\end_layout

\begin_layout Itemize
Inkscape: 0.48.1
\end_layout

\end_deeper
\begin_layout Itemize
Setup / Launcher
\end_layout

\begin_deeper
\begin_layout Itemize
NSIS: 2.46 (18.04.2010)
\end_layout

\begin_layout Itemize
PSPad: 4.5.6 (als Editor für NSIS Skripts, siehe: http://nsis.sourceforge.net/PSPad)
\end_layout

\begin_layout Itemize
Launch4J: 3.0.2 (02.01.2011)
\end_layout

\begin_layout Itemize
Ant: 1.8.1
\end_layout

\begin_layout Itemize
Jar Bundler: 13.7.0 (Mac OS X 10.6.8)
\end_layout

\end_deeper
\begin_layout Itemize
Libraries
\end_layout

\begin_deeper
\begin_layout Itemize
JFreechart: 1.0.14 (incl.
 JCommon: 1.0.17)
\end_layout

\begin_layout Itemize
JXLayer: 3.0.4
\end_layout

\begin_layout Itemize
SwingX: 1.6
\end_layout

\begin_layout Itemize
Freeheap: 2.1.1
\end_layout

\end_deeper
\begin_layout Itemize
Dokumentation:
\end_layout

\begin_deeper
\begin_layout Itemize
LibreOffice: 3.5.4.2
\end_layout

\begin_layout Itemize
Lyx: 2.0.0
\end_layout

\begin_layout Itemize
pdfTeX: 3.1415926-1.40.10-2.2
\end_layout

\begin_layout Itemize
GIMP: 2.6.11
\end_layout

\begin_layout Itemize
Dia 0.97.2
\end_layout

\begin_layout Itemize
Microsoft Visio 2010
\end_layout

\begin_layout Itemize
Microsoft Excel 2007
\end_layout

\end_deeper
\begin_layout Itemize
Codedokumentation
\end_layout

\begin_deeper
\begin_layout Itemize
Doxygen: 1.7.3
\end_layout

\end_deeper
\begin_layout Subsection

\series bold
SimulationJepLib-2.4.1
\end_layout

\begin_layout Standard
Der Projekt SimulationJepLib-2.4.1 enthält den von uns verwendeten Parser,
 der auch für die Berechnungen des Internen Simulationsplugins verwendet
 wird.
 Dieser Parser steht unter der GPL, wird jedoch leider nicht mehr weiterentwicke
lt.
 Es gibt nun eine kommerzielle Lösung, die etwas mehr Funktionsumfang hat
 und laut der Herstellerfirma Faktor 2 schneller ist.
 Die Komerzielle Lösung kommt für unser Projekt nicht in Frage, wir haben
 den Parser komplett ins Projekt übernommen, und auch Anpassungen vorgenommen,
 z.B.
 um Warnungen mit Java 1.6 zu vermeiden und um kleine Fehler zu beheben.
\end_layout

\begin_layout Standard
Somit ist dies ein 
\begin_inset Quotes eld
\end_inset

Fork
\begin_inset Quotes erd
\end_inset

 des Originals, und muss innerhalb des Simulationsprojektes gewartet werden,
 es sind keine externen Updates zu erwarten.
 Der Parser hat jedoch ein weitaus höheren Umfang als bei der Simulation
 benötigt wird, und es sind Unittests für den Parser vorhanden.
 Daher sollte dies kein Problem darstellen, da warscheinlich keine Fehler
 mehr im Parser vorhanden sind, welche die Simulation beeinträchtigen könnten.
\end_layout

\begin_layout Subsection
Erstellen eines neuen Simulationsplugins
\end_layout

\begin_layout Standard
Es wird ein neues Javaprojekt erstellt, mit dem Namen «SimulationPlugin.Sinnlos».
 In den Projekteinstellungen wird der «Java Build Path» konfiguriert, es
 werden folgende Projekte referenziert:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Bildschirmfoto-Properties for SimulationPlugin.Sinnlos .png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Java Buildpath
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
BJavalibs: Nötig für die Klasse Settings, welche die Einstellungen der Applikati
on zur Verfügung stellt.
 Alle Einstellungen, die gelesen/geschrieben werden, erhalten zusätzlich
 ein Prefix beim Namen.
 Wird also z.B.
 der Key 
\begin_inset Quotes eld
\end_inset

hallo
\begin_inset Quotes erd
\end_inset

 gelesen, wird intern 
\begin_inset Quotes eld
\end_inset

prefix.hallo
\begin_inset Quotes erd
\end_inset

 gelesen, wobei der Prefix in diesem Falle 
\begin_inset Quotes eld
\end_inset

simplugin.<name des Plugins>
\begin_inset Quotes erd
\end_inset

 ist.
\end_layout

\begin_layout Itemize
ExternLibraries: wird benötigt für «JXTaskPane», welches von SwingX stammt.
 Dies ist ein Element in der Sidebar der Simulationsapplikation.
\end_layout

\begin_layout Itemize
Model: Das Model wird benötigt, da es alle Daten enthält
\end_layout

\begin_layout Itemize
Plugin: Die generelle definition des Plugins wird benötigt, weil wir ein
 Plugin implementieren
\end_layout

\begin_layout Itemize
SimulationJepLib-2.4.1: Wird benötigt aufgrund von «SimulationModelException»
 (und ggf.
 den davon erbenden Klassen, die alle auch zur Verfügung stehen)
\end_layout

\begin_layout Itemize
SimulationPlugin: Die definition des Simulationplugins
\end_layout

\begin_layout Standard
Es wird eine neue Package erstellt, hier «ch.zhaw.simulation.sim.sinnlos» die
 Package muss unique sein, es dürfen nicht zwei Plugins die gleichen Package
 Namen verwenden, ansonsten kann es zu Problemen kommen!
\end_layout

\begin_layout Standard
Es wird eine neue Klasse erstellt: «SimulationSinnlosPlugin», welche «Simulation
Plugin» implementiert.
 Alle erforderlichen Methoden werden in die Klasse eingefügt: Bei Eclipse
 «Add unimplemented methods», dies erstellt 10 Methoden:
\end_layout

\begin_layout Itemize
public boolean load() throws Exception: Die Initialisierung des Plugins
 beim laden, wird im Normalfall nicht benötigt.
\end_layout

\begin_layout Itemize
public void unload(): Diese Methode wird vor dem Beenden der Applikation
 aufgerufen.
 Grundsätzlich ist es möglich, Plugins wärend der Laufzeit zu entladen/neu
 zu laden, wird jedoch hier von der Applikation nicht unterstützt.
\end_layout

\begin_layout Itemize
public JPanel getSettingsPanel(): Wird hier ein Wert != null zurückgegeben,
 wird dieser als eigener Tab in den Einstellungen angezeigt.
\end_layout

\begin_layout Itemize
public JXTaskPane getConfigurationSidebar(SimulationType type): Wird hier
 ein Wert != null zurückgegeben, wird das Panel in der Sidebar angezeigt.
 «type» gibt an, ob die Konfiguration für ein XY oder für ein Flow-Model
 benötigt wird.
\end_layout

\begin_layout Itemize
public void init(Settings settings, SimulationConfiguration config, PluginDataPr
ovider provider): Hier wird das Plugin normalerweise initialisiert.
 «settings» sind die globalen Einstellungen, die auf Applikationsebene gespeiche
rt werden, wie z.B.
 Defaultwerte.
 «config» sind die Einstellungen des aktuellen Dokuments, werden gespeichert
 aber sind immer vom aktuellen Dokument abhängig und nicht global! «provider»
 stellt Objekte zur Verfügung, die z.B.
 für die GUI benötigt werden:
\end_layout

\begin_deeper
\begin_layout Itemize
public JFrame getParent(): Wenn ein Dialog angezeigt werden soll kann dies
 als parent verwendet werden, und der Dialog kann mit setLocationRelativeTo(pare
nt); zentriert auf dem parent angezeigt werden.
\end_layout

\begin_layout Itemize
public ExecutionListener getExecutionListener(): Hier werden alle Statusmeldunge
n übermittelt (Fehler/Progress etc.)
\end_layout

\begin_layout Itemize
public SimulationType getSimulationType(): Hier erhalten wir nochmals den
 Simulationstyp (FLOW/XY)
\end_layout

\end_deeper
\begin_layout Itemize
public void checkDocument(SimulationDocument doc) throws SimulationModelExceptio
n: Prüft ob eine Simulation möglich ist.
 Wenn das Plugin keine Dichten unterstützt, kann dies hier abgefangen werden.
\end_layout

\begin_layout Itemize
public void executeSimulation(SimulationDocument doc) throws Exception:
 Führt die Simulation aus
\end_layout

\begin_layout Itemize
public SimulationCollection getSimulationResults(SimulationDocument doc):
 Gibt die Resultate der Flow Simulation zurück, wird immer verwendet (da
 auch die XY Simulation Flow Simulationen enthält)
\end_layout

\begin_layout Itemize
public Vector<XYDensityRaw> getXYResults(SimulationDocument doc): Gibt die
 Resultate der XY Simulation zurück
\end_layout

\begin_layout Itemize
public void cancelSimulation(): Wird aufgerufen, wenn die Simulation abgebrochen
 werden soll (von extern)
\end_layout

\begin_layout Standard
Es ist davon auszugehen, dass alle Daten, die dem Simulationsplugin übergeben
 werden, bereits validiert sind, also Formeln etc.
 Daher ist keine Validierung im Plugin erforderlich.
 Wenn ungültige Daten übergeben werden, ist dies nicht im Plugin abzufangen,
 sondern in der Applikation.
 Wir vervollständigen nun den Code mit folgendem Beispiel:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Plugin Beispiel,caption=SimulationSinnlosPlugin.java,
 language=Java]
\end_layout

\begin_layout Plain Layout

package ch.zhaw.simulation.sim.sinnlos;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import java.util.Vector;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import javax.swing.JPanel;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import org.jdesktop.swingx.JXTaskPane;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import butti.javalibs.config.Settings;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.math.exception.SimulationModelException;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.SimulationDocument;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.SimulationType;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.flow.SimulationFlowModel;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.flow.element.SimulationContainerData;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.simulation.SimulationConfiguration;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.ExecutionListener;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.ExecutionListener.FinishState;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.PluginDataProvider;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.SimulationPlugin;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.data.SimulationCollection;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.plugin.data.XYDensityRaw;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class SimulationSinnlosPlugin implements SimulationPlugin {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	private ExecutionListener execListener;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public boolean load() throws Exception {
\end_layout

\begin_layout Plain Layout

		// erfolgreich geladen, bei return false kann das Plugin nicht verwendet
\end_layout

\begin_layout Plain Layout

		// werden!
\end_layout

\begin_layout Plain Layout

		return true;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void unload() {
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public JPanel getSettingsPanel() {
\end_layout

\begin_layout Plain Layout

		// keine Einstellungen (Einstellungsidalog)
\end_layout

\begin_layout Plain Layout

		return null;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public JXTaskPane getConfigurationSidebar(SimulationType type) {
\end_layout

\begin_layout Plain Layout

		// keine Einstellungen (Sidebar)
\end_layout

\begin_layout Plain Layout

		return null;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void init(Settings settings, SimulationConfiguration config, PluginDataP
rovider provider) {
\end_layout

\begin_layout Plain Layout

		this.execListener = provider.getExecutionListener();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void checkDocument(SimulationDocument doc) throws SimulationModelExcepti
on {
\end_layout

\begin_layout Plain Layout

		// Validierung immer erfolgreich
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void executeSimulation(final SimulationDocument doc) throws Exception
 {
\end_layout

\begin_layout Plain Layout

		if (doc.getType() == SimulationType.FLOW_SIMULATION) {
\end_layout

\begin_layout Plain Layout

			new Thread(new Runnable() {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				@Override
\end_layout

\begin_layout Plain Layout

				public void run() {
\end_layout

\begin_layout Plain Layout

					SimulationSinnlosPlugin.this.execListener.executionStarted("Simulation
 gestartet");
\end_layout

\begin_layout Plain Layout

					try {
\end_layout

\begin_layout Plain Layout

						Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

					} catch (InterruptedException e) {
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

					SimulationSinnlosPlugin.this.execListener.setState(50);
\end_layout

\begin_layout Plain Layout

					SimulationSinnlosPlugin.this.execListener.setExecutionMessage("Fast fertig!");
\end_layout

\begin_layout Plain Layout

					try {
\end_layout

\begin_layout Plain Layout

						Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

					} catch (InterruptedException e) {
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

					SimulationFlowModel flowModel = doc.getFlowModel();
\end_layout

\begin_layout Plain Layout

					for (SimulationContainerData c : flowModel.getSimulationContainer())
 {
\end_layout

\begin_layout Plain Layout

						System.out.println("-> " + c.getName() + " = " + c.getFormula());
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

					SimulationSinnlosPlugin.this.execListener.executionFinished("Keine Implementat
ion", FinishState.ERROR);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}).start();
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			// Unerwarteter Fehler, wird von der Applikation gehändelt
\end_layout

\begin_layout Plain Layout

			throw new Exception("Der Programmierer hatte Feierabend!");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public SimulationCollection getSimulationResults(SimulationDocument doc)
 {
\end_layout

\begin_layout Plain Layout

		// keine Daten...
\end_layout

\begin_layout Plain Layout

		return null;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public Vector<XYDensityRaw> getXYResults(SimulationDocument doc) {
\end_layout

\begin_layout Plain Layout

		// keine Daten...
\end_layout

\begin_layout Plain Layout

		return null;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void cancelSimulation() {
\end_layout

\begin_layout Plain Layout

		// Kann nicht abgebrochen werden...
\end_layout

\begin_layout Plain Layout

		this.execListener.setExecutionMessage("Nicht möglich!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unser Plugin ist somit fertig, aber es wird noch nicht geladen.
 Um es laden zu können muss zuerst ein XML File mit den Daten des Plugins
 erstellt werden.
 Dies wird vom Plugin Loader benötigt, dies geschieht am einfachsten indem
 ein bereits vorhandenes XML File eines anderen Plugins kopiert und angepasst
 wird.
 Das File «plugin.xml» wird direkt im Root des Projektes abgelegt, und zwar
 mit folgendem Inhalt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=XML,caption=simulation.xml, language=html]
\end_layout

\begin_layout Plain Layout

<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

<plugin>
\end_layout

\begin_layout Plain Layout

	<class>ch.zhaw.simulation.sim.sinnlos.SimulationSinnlosPlugin</class>
\end_layout

\begin_layout Plain Layout

	<name>Sinnlos</name>
\end_layout

\begin_layout Plain Layout

	<description>Beispiel Plugin</description>
\end_layout

\begin_layout Plain Layout

	<author>Hans Muster</author>
\end_layout

\begin_layout Plain Layout

</plugin>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um das Plugin nun zu kompilieren, muss noch ein Antfile erstellt werden.
 Auch dieses kann von einem bestehenden Plugin kopiert werden.
 Jedoch muss dann bei jeder Änderung das Antfile erneut ausgeführt werden,
 was ziemlich mühsam ist.
 Daher gehen wir einen einfacheren Weg: wir kopieren das plugin.xml im Projekt
 «Simulation» in den Ordner «plugin/simulation» unter dem Name «Sinnlos.xml»
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Bildschirmfoto-5.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sinnlos.xml im korrekten Verzeichnis
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Danach wird die Applikation gestartet.
 Dies geschieht durch ausführen der Klasse «ch.zhaw.simulation.startup.SimulationMai
n» aus dem Projekt «Simulation».
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Fehler.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Fehler beim laden des Plugins
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nun erscheint ein Fehler, dass das Plugin nicht geladen werden konnte.
 Der Fehler wird geloggt, jedoch wird die Exception incl.
 allen Texten (in diesem Fall sind keine Zusatzlichen Texte vorhanden) auf
 der Konsole ausgegeben.
 In diesem Fall konnte die Klasse nicht geladen werden.
 Dies kann einfach gelöst werden, indem beim Projekt «Simulation» das Projekt
 «SimulationPlugin.Sinnlos» in den Referenzierten Projekte (Java Build Path)
 hinzugefügt wird.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Bildschirmfoto-Properties for Simulation .png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Projekt «Simulation» Einstellungen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Danach sollte das Plugin korrekt funktionieren, es muss noch in der Sidebar
 ausgewählt werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Bildschirmfoto-6.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Wählen des neuen Plugins
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Testen/Weiterentwickeln ist jetzt dem Leser überlassen!
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_plugin/Bildschirmfoto-7.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Start der Simulation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Erstellen eines neuen GUI Elementes
\end_layout

\begin_layout Standard
Hier wird erklärt, wie ein neues Element eingefügt werden kann.
 Diese Anleitung ist stark vereinfacht.
 Als Referenz sollten bereits vorhandene Implementationen verwendet werden
 und nicht diese Anleitung.
 (Das Beispiel basiert auf dem Meso-Kompartment und hat auch einige Codestücke
 von dort, die der einfachheitshalber übernommen wurden)
\end_layout

\begin_layout Enumerate
Im Projekt Model wird eine neue Klasse eingefügt, dies ist der Model Teil
 des «Blocks»
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=BlockData.java, language=Java]
\end_layout

\begin_layout Plain Layout

package ch.zhaw.simulation.model.xy;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.element.AbstractNamedSimulationData;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class BlockData extends AbstractNamedSimulationData {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public BlockData(int x, int y) {
\end_layout

\begin_layout Plain Layout

		super(x, y);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public String getDefaultName() {
\end_layout

\begin_layout Plain Layout

		return "b";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public int getWidth() {
\end_layout

\begin_layout Plain Layout

		return 30;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public int getHeight() {
\end_layout

\begin_layout Plain Layout

		return 30;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Im Projekt «Editor.XY» wird eine neue Package erstellt: «ch.zhaw.simulation.editor.xy.
element.box»
\end_layout

\begin_layout Enumerate
Es werden zwei Klassen erstellt «BlockImage» und «BlockView» dies ist der
 UI Teil der Applikation.
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=BlockImage.java, language=Java]
\end_layout

\begin_layout Plain Layout

package ch.zhaw.simulation.editor.xy.element.box;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import java.awt.Color;
\end_layout

\begin_layout Plain Layout

import java.awt.Graphics2D;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import butti.javalibs.util.DrawHelper;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.editor.elements.GuiImage;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.sysintegration.GuiConfig;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class BlockImage extends GuiImage {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public BlockImage(int size, GuiConfig config) {
\end_layout

\begin_layout Plain Layout

		super(size, size, config, false);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	public void drawImage(Graphics2D g, boolean selected) {
\end_layout

\begin_layout Plain Layout

		DrawHelper.antialisingOn(g);
\end_layout

\begin_layout Plain Layout

		g.setPaint(Color.PINK);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		g.fillRect(0, 0, getWidth(), getHeight());
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		g.setPaint(config.getObjectBorder(selected));
\end_layout

\begin_layout Plain Layout

		g.drawRect(0, 0, getWidth(), getHeight());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=BlockView.java, language=Java]
\end_layout

\begin_layout Plain Layout

package ch.zhaw.simulation.editor.xy.element.box;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.editor.elements.GuiImage;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.editor.view.GuiDataTextElement;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.editor.xy.XYEditorControl;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.model.xy.BlockData;
\end_layout

\begin_layout Plain Layout

import ch.zhaw.simulation.sysintegration.GuiConfig;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class BlockView extends GuiDataTextElement<BlockData> {
\end_layout

\begin_layout Plain Layout

	private static final long serialVersionUID = 1L;
\end_layout

\begin_layout Plain Layout

	private BlockImage image;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public BlockView(XYEditorControl control, BlockData data) {
\end_layout

\begin_layout Plain Layout

		super(data, control);
\end_layout

\begin_layout Plain Layout

		GuiConfig guiconf = control.getSysintegration().getGuiConfig();
\end_layout

\begin_layout Plain Layout

		this.image = new BlockImage(guiconf.getMesoSize(), guiconf);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		dataChanged();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		this.textY = 20;
\end_layout

\begin_layout Plain Layout

		this.questionmarkY = 30;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	@Override
\end_layout

\begin_layout Plain Layout

	protected GuiImage getImage() {
\end_layout

\begin_layout Plain Layout

		return image;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Nun muss ein Button eingefügt werden, um den Block hinzuzufügen.
 Dies geschieht in ch.zhaw.simulation.toolbar.xy.XYToolbar.
 Hier wird vor 
\begin_inset Quotes eld
\end_inset

addGlobalIcon();
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=Ausschnitt, language=Java]
\end_layout

\begin_layout Plain Layout

		toolbar.add(new ToolbarAction("Block", addShadow(GuiImage.drawToImage(new
 BlockImage(24, config)))) {
\end_layout

\begin_layout Plain Layout

			@Override
\end_layout

\begin_layout Plain Layout

			public void actionPerformed(ActionEvent e) {
\end_layout

\begin_layout Plain Layout

				fireMenuActionPerformed(new MenuToolbarAction(MenuToolbarActionType.XY_ADD_BL
OCK));
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		});
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

eingefügt.
 Dies ergibt einen Compiler Fehler, da «MenuToolbarActionType.XY_ADD_BLOCK»
 nicht erfasst ist, also erfassen wir es doch.
 Bei Eclipse geht das mit CTRL+1
\end_layout

\begin_layout Enumerate
Nun fügen wir in der Datei ch.zhaw.simulation.editor.xy.XYEditorControl vor 
\begin_inset Quotes eld
\end_inset

case XY_ADD_MESO:
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=Ausschnitt, language=Java]
\end_layout

\begin_layout Plain Layout

		case XY_ADD_BLOCK:
\end_layout

\begin_layout Plain Layout

			addBlock();
\end_layout

\begin_layout Plain Layout

			return true;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Nach ende der Methode menuActionPerformedOverwrite einfügen!
\end_layout

\begin_layout Plain Layout

	private void addBlock() {
\end_layout

\begin_layout Plain Layout

		cancelAllActions();
\end_layout

\begin_layout Plain Layout

		BlockData block = new BlockData(0, 0);
\end_layout

\begin_layout Plain Layout

		addComponent(block, "Block");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Nun wird ein Blockelement erstellt, wenn wir auf den Button drücken.
 Wir sind noch nicht fertig, aber wir starten nun die Applikation (SimulationMai
n) und drücken auf den Button: Es erscheint eine Exception, welche uns auch
 sagt, wo wir noch arbeiten müssen: 
\begin_inset Quotes eld
\end_inset

Unknown SimulationObject: ch.zhaw.simulation.model.xy.BlockData at ch.zhaw.simulation.ed
itor.view.AbstractEditorView.dataAdded(AbstractEditorView.java:495)
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
Die Exception tritt im AbstraktenEditor auf, wir wollen aber eine Implementation
 alleine für den XYEditor.
 Daher müssen wir in der Klasse «XYEditorView» ein Stuck Code einfügen.
 In der Methode «dataAddedImpl» vor 
\begin_inset Quotes eld
\end_inset

return false;
\begin_inset Quotes erd
\end_inset

 wird dieser Code eingefügt:
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=Block Beispiel,caption=Ausschnitt, language=Java]
\end_layout

\begin_layout Plain Layout

		if (o instanceof BlockData) {
\end_layout

\begin_layout Plain Layout

			add(new BlockView(control, (BlockData) o));
\end_layout

\begin_layout Plain Layout

			return true;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Danach fügen wir nochmals einen solchen Block ein, und siehe da, es funktioniert
!
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_element/BlockView.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Block
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Was jetzt noch fehlt, ist das Laden/Speichern des Blocks.
 Dies muss in «XmlModelLoader» und «XmlContentsSaver» implementiert werden.
 Beim Speichern muss eine Implementation für «visitSimulationData» erstellt
 werden und beim Laden in der Methode «parseNode».
 Dies erfolgt analog des vorhandenen Codes für andere Elemente und wird
 hier nicht mehr im Detail erläutert.
\end_layout

\begin_layout Subsection
Einfügen neuer Icons
\begin_inset CommandInset label
LatexCommand label
name "sub:Einfügen-neuer-Icons"

\end_inset


\end_layout

\begin_layout Standard
Als Icons wurden hauptsächlich SVG Icons verwendet.
 Dies bedeutet, dass die Icons auf eine beliebige Grösse skaliert werden
 können und trotzdem nicht an Qualität verlieren.
 Die Icons stammen von:
\end_layout

\begin_layout Itemize
Faenza: http://tiheum.deviantart.com/art/Faenza-Icons-173323228
\end_layout

\begin_layout Itemize
Humanity (Ubuntu/Canonical): https://launchpad.net/humanity
\end_layout

\begin_layout Standard
Die Icons wurden teilweise angepasst.
 Dies wurde mit Inkscape vorgenommen.
\end_layout

\begin_layout Standard
Anfangs wollten wird die Icons mit einem Java SVG Parser öffnen und darstellen.
 Dies ist jedoch relativ langsam, zudem waren die SVG Libraries extrem langsam,
 verglichem mit dem Laden eines .png.
 Daher haben wir uns entschieden, dass wir zwar immer noch bei den SVG bleiben,
 es wird jedoch bei der ersten Verwendung durch Inkscape in ein PNG der
 richtigen Grösse konvertiert.
 Dadurch ist die Grafik immer noch beliebig skalierbar, aber auch schnell
 im Laden.
 Die Klasse «IconLoader» konvertiert die Bilder automatisch, sofern:
\end_layout

\begin_layout Itemize
Die Applikation nicht aus einem .jar gestartet wird
\end_layout

\begin_layout Itemize
Der Ordner in der die Applikation liegt auf 
\begin_inset Quotes eld
\end_inset

/bin
\begin_inset Quotes erd
\end_inset

 endet (default von Eclipse)
\end_layout

\begin_layout Itemize
Inkscape im PATH ist.
\end_layout

\begin_layout Standard
Ein neues Icon wird im Projekt «Sysintegration» eingefügt, in der Package:
 «ch.zhaw.simulation.icon.svg».
\end_layout

\begin_layout Standard
Danach wird die Applikation gestartet, das Icon wird geladen mit: 
\begin_inset Quotes eld
\end_inset

IconLoader.getIcon("<name ohne extension>", <Grösse in px>)
\begin_inset Quotes erd
\end_inset

.
 Das Bild wird automatisch konvertiert und geladen.
 Wenn es nicht klappt, wird auf «stderr» ein Fehler ausgegeben und stattdessen
 ein komplett rotes Bild angezeigt.
\end_layout

\begin_layout Subsection
Ant Buildsystem
\end_layout

\begin_layout Standard
Um das Projekt zu builden wird Ant verwendet.
 Ant ist zu finden auf http://ant.apache.org/, und wird hier nicht weiter
 erläutert, es wird stattdessen auf das Handbuch und auf die Onlinedokumentation
 verwiesen.
\end_layout

\begin_layout Standard
Das Projekt, in welchem gebuildet wird, ist «SimulationBuild».
 Dieses enthält ein «build.xml», welches alle «build.xml» der Projekt aufruft.
 Dieses kompiliert alle Java Projekte und kopiert die nötigen Ressourcen
 in den Ordner build/distrib bzw.
 build/tmp.
 Diese Skripts funktionieren grundsätzlich systemunabhängig.
\end_layout

\begin_layout Subsubsection
Setup
\end_layout

\begin_layout Standard
Der Setup wird ebenfalls vom Ant Buildsystem erstellt.
 Es hat separate Skripts für jedes Betriebssystem, welche nicht unter allen
 Betriebssystem ausgeführt werden können aufgrund von technischen Beschränkungen.
 Verschiedene Betriebssysteme handhaben Einstellungen wie Dateitypen, Icons,
 Executable, Setup etc.
 verschieden.
 Hier eine kurze Übersicht:
\end_layout

\begin_layout Itemize
Linux (Unix, Posix)
\end_layout

\begin_deeper
\begin_layout Itemize
Applikationen werden normalerweise als Packages (.deb, .rpm..., technisch meist
 tar.gz Archive) installiert, welche nicht manuell heruntergeladen werden,
 sondern über Repositories bereitgestellt werden.
\end_layout

\begin_layout Itemize
Updates werden automatisch über die Repsitories vorgenommen.
 (ausser bei von Hand installierter Software)
\end_layout

\begin_layout Itemize
Die komplette Konfiguration der Dateizuordnungen etc.
 wird über Dateien vorgenommen, welche ebenfalls in der Package enthalten
 sind.
\end_layout

\begin_layout Itemize
Icons, Übersetzungen etc.
 werden als Files in vordefinierten Ordnern abgelegt (z.B.
 /usr/shared)
\end_layout

\begin_layout Itemize
Abhängigkeiten werden normalerweise über den Packagemanager automatisch
 aus den Repositiories nachinstalliert.
 (also alle für die Laufzeit notwendigen Libraries)
\end_layout

\end_deeper
\begin_layout Itemize
Mac OS X (
\begin_inset Quotes eld
\end_inset

Darwin
\begin_inset Quotes erd
\end_inset

, Unix, Posix)
\end_layout

\begin_deeper
\begin_layout Itemize
Applikationen werden entweder über den Appstore Installiert, dann verhält
 sich das ganze gleich wie bei Linux mit den Repsitories.
 Ansonsten können Applikationen einfach per Drag & Drop in den «Programme»
 Ordner gezogen werden, und sind somit installiert.
\end_layout

\begin_layout Itemize
Updates werden über de Appstore vorgenommen, bei von Hand installierten
 Anwendungen muss dieses von Hand vorgenommen werden, wobei viele Applikationen
 einen eigenen Updatemechanismus mitbrigen.
\end_layout

\begin_layout Itemize
Die Applikation selbst ist keine Datei, sondern ein Ordner der auf .app endet.
 Dieser wird von Mac OS X in der GUI als einzelne Datei dargestellt.
 Die Bezeichnung eines solchen Ordners ist eine 
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

 (nicht zu verwechseln mit der 
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

 bei Linux).
 Diese 
\begin_inset Quotes eld
\end_inset

Package
\begin_inset Quotes erd
\end_inset

 enthält auch die Information welche Dateitypen von der Applikation unterstützt
 werden.
\end_layout

\begin_layout Itemize
Icons, Übersetzungen etc.
 sind als Files in den Packages enthalten
\end_layout

\begin_layout Itemize
Libraries sind entweder bereits im System vorhanden, oder können in den
 Packages untergebracht werden und sind somit der Applikation zugeordnet.
\end_layout

\end_deeper
\begin_layout Itemize
Windows (Microsoft Windows)
\end_layout

\begin_deeper
\begin_layout Itemize
Applikationen werden im Normalfall von Hand installiert und können über
 einen Setup.exe oder über ein .msi Paket installiert werden.
\end_layout

\begin_layout Itemize
Updates werden von Hand installiert, sofern die Applikation keinen Mechanismus
 dafür bietet.
\end_layout

\begin_layout Itemize
Die Zuordnungen der Dateien liegt in der Registrierung und muss entweder
 vom Setup oder von Programm selbst beim Starten angelegt werden.
 Dieser muss bei der Deinstallation auch wider entfernt werden.
\end_layout

\begin_layout Itemize
Ausführbare Dateien (.exe) können Ressourcen enthalten, z.B.
 Icons.
 Aber z.B.
 Shared Libraries (.dll) können nicht als Ressourcen geladen werden und müssen
 als separate Datei abgelegt werden.
\end_layout

\begin_layout Itemize
Libraries müssen vom Setup irgendwo abgelegt werden, dies kann das Programmverze
ichnis oder auch das System32 Verzeichnis sein.
 Werden verschiedene Versionen der gleichen Library installiert, so kann
 dies zu Probleme kommen, es gibt keine Verwaltung oder ähnliches.
\end_layout

\end_deeper
\begin_layout Standard
Unser Setup wird infolge auf drei verschiedene Arten erstellt.
 Für Linux wird keine Package, sondern nur eine .zip Datei mit allen zur
 Laufzeit erforderlichen Daten bereitgestellt.
 Da es sich um eine Open Source Applikation handelt, ist anzustreben, dass
 diese in die offiziellen Repositories gebracht wird und somit Updates und
 Abhängigkeiten automatisch installiert werden können.
\end_layout

\begin_layout Standard
Für Mac OS X wird eine Package erstellt, welche einfach per Drag & Drop
 installiert werden kann.
 Dies wird mit «build.xml» aus dem Unterordner «mac» vorgenommen.
 Um den Setup zu erstellen, muss php-cli installiert sein.
 Es wird ein PHP File verwendet, um das info.plist File zu erstellen (es
 handelt sich um ein sehr kleines Skript, welches problemlos auf eine andere
 Skriptsprache portiert werden könnte).
 Zu beachten ist, dass die Erstellung des Mac OS X Setup auf Windows nicht
 funktioniert, da unter Windows die Executable Flags im Filesystem nicht
 vorhanden sind.
 Der Wrapper für Mac OS X kann mit 
\begin_inset Quotes eld
\end_inset

/Developer/Applications/Utilities/Jar Bundler
\begin_inset Quotes erd
\end_inset

 erstellt werden.
\end_layout

\begin_layout Standard
Für Windows wurde ein Launcher erstellt (mit Launch4J: http://launch4j.sourceforg
e.net/).
 Dieser Launcher startet die Applikation.
 Für den Setup wurde NSIS (Nullsoft Scriptable Install System: http://nsis.source
forge.net) verwendet.
 Es muss das Setupskript «Simulation.nsi» mit NSIS kompiliert werden.
 Dies muss unter Windows geschehen.
\end_layout

\begin_layout Standard
Für Linux ist nur ein Shellscript vorhanden, dies wird beim Build automatisch
 erstellt.
\end_layout

\begin_layout Subsection
Vorhandene Fehler/Fehlende Funktionalität
\end_layout

\begin_layout Standard
Die Applikation ist noch nicht fertig, es gibt noch Fehler in der Applikation
 und es gibt noch Funktionen die wünschenswert wären.
 Hier wird aufgelistet, was bekannt ist bzw.
 besprochen wurde.
 Fehler sind teilweise mit TODOs im Code markiert, auch noch einige Details,
 welche hier nicht aufgelistet sind.
\end_layout

\begin_layout Itemize
Bugs, Fehler: Fehler, die behoben werden müssen, um die korrekte Funktionalität
 zu gewährleisten
\end_layout

\begin_deeper
\begin_layout Itemize
Fehler im Simulationsmodell werden meist korrekt erkannt und dargestellt,
 trotzdem ist es teilweise möglich eine Simulation zu starten, die dann
 fehlschlägt.
 Dies sollte nicht möglich sein.
\end_layout

\begin_layout Itemize
Im Flow Model wird nicht immer eine genug grosse Fläche neu gezeichnet,
 wenn ein Fluss verändert wird.
 Teilweise wird sichtbar nur ein Teil neu gezeichnet, was dann ein 
\begin_inset Quotes eld
\end_inset

Loch
\begin_inset Quotes erd
\end_inset

 im Fluss zur Folge hat.
 Durch aufspannen eines Selektionsvierecks wird alles korrekt neu gezeichnet.
 Das Problem ist, dass die Bounds der Bezierkurve beim verschieben nicht
 immer korrekt berechnet werden, es muss der alte und der neue Bereich berechnet
 und die Vereinigungsmenge neu gezeichnet werden.
\end_layout

\begin_layout Itemize
Beim exportieren eines XY Diagramms wird die Dichte nicht exportiert.
 Die Dichte wird jedoch exportiert, wenn die Simulationsresultate angezeigt
 werden und dann ein Bild exportiert wird.
\end_layout

\begin_layout Itemize
«NetbeansDirchooser» hat ein Bug beim vertikalen scrollen wird die horizontale
 Scrollbar kleiner.
\end_layout

\end_deeper
\begin_layout Itemize
Darstellungsunschönheiten
\end_layout

\begin_deeper
\begin_layout Itemize
Die Mac OS X Toolbar Implementation funktioniert nicht überall korrekt und
 musste daher teilweise abgeschaltet werden.
 Dies hat zur Folge, dass Buttons angezeigt werden, welche bei Mac OS X
 unüblich sind.
\end_layout

\begin_layout Itemize
Die Density Legende ist nicht besonders schön dargestellt, es wird viel
 Platz verschwendet.
 Gegebenenfalls könnte die Legende auch horizontal statt vertikal angezeigt
 werden.
\end_layout

\end_deeper
\begin_layout Itemize
Missing Features
\end_layout

\begin_deeper
\begin_layout Itemize
Beim Copy & Paste und beim Vektorgrafik Export wäre es wünschenswert, Teilbereic
he exportieren zu können.
 Das Interface «ImageExportable» sieht dies vor, jedoch wird es bisher von
 keiner Implementation unterstützt.
\end_layout

\begin_layout Itemize
Wird ein Name eines Simulationsobjekt angepasst, z.B.
 einem Container, wäre es wünschenswert, wenn alle Formeln refactored werden.
\end_layout

\begin_layout Itemize
Die Dichte sollte nicht nur farblich, sondern auch mit Pfeilen dargestellt
 werden können.
\end_layout

\begin_layout Itemize
Die Klasse «ArrowDragView» ist zuständig, um eine Verbindung zwischen z.B.
 zwei Containern herzustellen.
 Auch wenn mit dem blauen Pfeil verbunden wird (beim selektierten Container),
 kann keine Flussverbindung mehr herstellt werden, wenn bereits eine Parameter
 Verbindung besteht.
 Die Verbindung kann nur über den Flusspfeil in der Toolbar hergestellt
 werden.
 Diese sollte korrigiert werden.
\end_layout

\begin_layout Itemize
Es sollte möglich sein in einem Flussdiagramm, das sich innerhalb eines
 XY-Diagramms befindet, auf z.B.
 die Globalen des XY-Diagramms zuzugreifen,.
 Dies ist momentan nicht möglich.
\end_layout

\begin_layout Itemize
Es ist nicht möglich, dass Meso-Kompartments verschmelzen/sich teilen.
 Dies sollte noch nachgeführt werden
\end_layout

\begin_layout Itemize
Die Applikation ist komplett auf Deutsch, es wurde kein Internationalisierungsys
tem verwendet.
 Dies sollte noch nachgeholt werden (z.B.
 Java Ressourcen oder gettext).
\end_layout

\end_deeper
\begin_layout Section
Benutzerhandbuch
\end_layout

\begin_layout Standard
Das Benutzerhandbuch soll die Grundlegenden Funktionen der Applikation beschreib
en.
 Es wird davon ausgegangen, dass die grundlegende Funktionsweise von Simulations
tools bereits bekannt ist, wie z.B.
 von Berkeley Madonna/Dynasys, die ähnlich funktionieren.
\end_layout

\begin_layout Subsection
Installation
\end_layout

\begin_layout Standard
Eine Javainstallation ist Voraussetzung, und es wird davon ausgegangen,
 dass diese auch vorhanden ist.
\end_layout

\begin_layout Subsubsection
Linux
\end_layout

\begin_layout Standard
Unter Linux wird das File «Simulation.tar.gz» z.B.
 auf den Desktop kopiert
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/linux/Bildschirmfoto am 2012-06-06 12_44_45.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Setup
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/linux/Bildschirmfoto am 2012-06-06 12_45_44.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Zipfile wird entpackt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/linux/Bildschirmfoto am 2012-06-06 12_46_02.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der neue Ordner wird geöffnet und «Simulation.sh» gestartet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/linux/Bildschirmfoto am 2012-06-06 12_46_57.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Es wird «Ausführen» gewählt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/linux/Bildschirmfoto am 2012-06-06 12_49_03.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Simulationsapplikation unter Linux
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Mac
\end_layout

\begin_layout Standard
Das Zipfile «Simulation.zip» wird per Drag & Drop z.B.
 auf den Desktop kopiert
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/mac/Bildschirmfoto 2012-06-06 um 12.29.04.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Setup
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/mac/Bildschirmfoto 2012-06-06 um 12.29.15.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Das Zipfile wird durch doppelklicken entpackt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/mac/Bildschirmfoto 2012-06-06 um 12.29.23.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die entpackte Applikation wird per Drag & Drop in den «Programme» Ordner
 kopiert
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn gewünscht kann noch eine Verknüpfung ins Dock erstellt werden, ansonsten
 kann die Applikation auch einfach aus dem Programme Ordner gestartet werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/mac/Bildschirmfoto 2012-06-06 um 12.30.44.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Simulationsapplikation unter Mac OS X
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Windows
\end_layout

\begin_layout Standard
Der Setup «Setup_Simulation.exe» wird gestartet
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Setup.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Setup
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Setup1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Lizenzbedingungen akzeptieren (GPL)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Setup2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ordner für die Installation wählen, normalerweise kann diese auf dem Standard
 belassen werden.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wurde die Installation an einem falschen Ort durchgeführt, so muss die Applikati
on deinstalliert und erneut installiert werden.
 Wird die Applikation einfach verschoben, so stimmen die Pfade, die in die
 vom Setup in die Registrierung geschrieben wurden, nicht mehr und die Applikati
on lässt sich unter Umständen nicht einmal mehr deinstallieren.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Setup3.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Installation erfolgreich
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Applikation wird mit drücken auf «Fertig stellen» gestartet.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Setup4.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Die Simulationsapplikation unter Windows
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/setup/win/Startmenü.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Der Startmenüeintrag über den sich die Applikation starten lässt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Portable Version
\end_layout

\begin_layout Standard
Die Portable Version benötigt keine Installation.
 Die Applikation wird als .zip zur Verfügung gestellt und wird einfach entpackt.
 Ist die Applikation entpackt, kann der komplette Ordner einfach kopiert
 werden, z.B.
 auf einen USB Stick, und kann dann an jedem beliebigen PC der über eine
 Java Runtime verfügt gestartet werden.
\end_layout

\begin_layout Standard
Unter Linux/Unix/Mac OS X wird die Applikation gestartet, indem das Shellscript
 Simulation.sh gestartet wird.
\end_layout

\begin_layout Standard
Unter Windows wird die Applikation gestartet, indem Simulation.exe gestartet
 wird.
\end_layout

\begin_layout Subsection
Übersicht/Begriffsdefinitionen
\end_layout

\begin_layout Standard
Das Bedienkonzept der Applikation ist relativ einfach.
 Auf den Einsatz eines Kontextmenüs wurde verzichtet.
 (Je nach Betriebssystem kann ein Kontextmenü angeboten werden, alle diese
 Aktionen sind jedoch auch mit Tastenkombinationen oder im Menü/der Toolbar
 zu finden).
\end_layout

\begin_layout Standard
Alle Wichtigen Operationen werden in der Toolbar dargestellt.
 Diese kann auch über ein Drop-Down Menü verfügen, dies wird mit einem kleinen
 Pfeil nach unten signalisiert.
 Für alle gebräuchlichen Aktionen wird eine Tastenkombination angeboten,
 siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Tastenkombinationen"

\end_inset

.
\end_layout

\begin_layout Standard
Editierschritte können Rückgängig gemacht werden (bis max.
 100 Schritte), dafür wird auf 
\begin_inset Quotes eld
\end_inset

Sind Sie sicher...
\begin_inset Quotes erd
\end_inset

 Nachfragen verzichtet.
 Trotzdem liegt es in der Verantwortung des Benutzers, regelmässig zu speichern
 und ggf.
 Backups anzulegen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Uebersicht.png
	lyxscale 25
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Übersicht Applikation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Beim Starten der Applikation wird das 
\series bold
Hauptfenster
\series default
 angezeigt.
 Dieses gibt es in zwei Varianten, eine für die XY Simulation und eine für
 die Flow Simulation.
 Diese sind abgesehen von einer leicht verschiedene Funktionalität jedoch
 identisch.
\end_layout

\begin_layout Enumerate
Die 
\series bold
Toolbar
\series default
, oben die 
\series bold
Menübar
\series default
.
 Links in der Toolbar sind die Elemente die eingefügt werden können.
 Weiter rechts sind die Speichern/Rückgängig/Widerherstellen und Layout
 Buttons
\end_layout

\begin_layout Enumerate
Die 
\series bold
Zeichnungsfläche
\series default
, hier wird das Model gezeichnet.
\end_layout

\begin_layout Enumerate
Die 
\series bold
Sidebar
\series default
, hier werden die Einstellungen für die Simulation und für die aktuell Selektier
ten Elemente vorgenommen.
\end_layout

\begin_layout Enumerate
Die 
\series bold
Statusleiste
\series default
.
 Hier wird der Benutzer darüber informiert, was er als nächstes machen kann.
\end_layout

\begin_layout Subsection
Erstellen eines einfachen Flow-Modells
\end_layout

\begin_layout Standard
Hier wird erläutert, wie ein Flow Modell erstellt werden kann.
\end_layout

\begin_layout Enumerate
Die Applikation wird gestartet/es wird «Datei/Neu» bzw.
 «Datei/Neu - Flow Model» gewählt, je nachdem, ob man bereits ein Flow oder
 ein XY Modell geöffnet hat.
\end_layout

\begin_layout Enumerate
Es wird ein Container erstellt: Entweder wird auf den grauen Zylinder in
 der Toolbar geklickt, oder es wird «C» gedrückt.
 Danach wird in die Zeichnungsfläche geklickt.
\end_layout

\begin_layout Enumerate
Wenn auf den Container geklickt wird, wird er orange.
 Er ist nun selektiert.
 Zudem wird oben rechts vom Container ein kleiner blauer Pfeil dargestellt.
 Mit diesem Pfeil können direkt Verbindungen vorgenommen werden.
 Verbindungen können aber auch über die Toolbar erstellt werden (der blaue,
 dicke Pfeil).
\end_layout

\begin_layout Enumerate
Die Verbindung wird ins Nichts, also auf eine freie Stelle im Hintergrund
 verbunden.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Bildschirmfoto-7.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ergebnis von Punkt 1 - 4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Es wird auf «con0» doppelgeklickt, dann wird der Wert 100 eingetragen und
 das Fenster wider geschlossen.
 Das Fragezeichen müsste nun verschwunden sein.
\end_layout

\begin_layout Enumerate
Es wird auf «fluss0» doppelgeklickt, dann wird der Wert 1 eingetragen und
 das Fenster wieder geschlossen.
 Auch hier müsste nun das Fragezeichen weg sein.
\end_layout

\begin_layout Enumerate
In der Sidebar wird «Interne Simulation» gewählt, als «Startzeit» wird 0,
 als «Endzeit» 150 und als «dt» 0.1 gewählt.
 Als Simulationstype kann «Euler» belassen werden.
\end_layout

\begin_layout Enumerate
Es wird auf «Simulieren» geklickt, oder «F9» gedrückt.
 Die Simulation läuft ab und zeigt folgendes Diagramm an: 
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Bildschirmfoto-8.png
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagramm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Interpretation des Diagramms: Der Container (rote Linie) enthält anfangs
 100, wird dann mit 1/Zeiteinheit entleert und erhält dann logischerweise
 beim Zeitpunkt 100 nur noch 0.
 Danach wird der Inhalt des Countainers negativ.
\end_layout

\begin_layout Subsection
Generelle Verwendung der Simulationsapplikation
\end_layout

\begin_layout Standard
Das Diagramm verfügt über Einstellungen, welche über das Kontextmenü oder
 über die Buttons in der Toolbar konfiguriert werden kann.
 Der Einstellungsdialog ermöglicht das Anpassen der Farben, der Schrift
 und der Beschriftung.
 Bei der Beschriftung wurde noch eine Spezialzeichen Tastatur angebracht,
 welche es ermöglicht Symbole zu wählen welche auf der Schweizer Tastatur
 nicht zur Verfügung stehen.
 Alle Änderungen der Einstellungen werden direkt im Diagramm dargestellt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Diagramm Einstellungen1.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Diagramm Einstellungen 2.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diagramm Einstellungen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Formeleditor, der überall zum Einsatz kommt verfügt über eine Toolbar,
 bei der alle Verfügbaren Variablen (Systemdefiniert, oder verbundene Parameter
 / Container) anzeigt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Formelditor.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Formeleditor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Formelditor parst die Formel automatisch.
 Ca.
 1 Sekunde nach der letzten Eingabe steht in der Statusleiste ob die Formel
 fehlerfrei ist, oder was für Fehler das vorhanden sind.
 Der Formeleditor verfügt über Syntaxhilighting, welches z.B.
 Variablen farblich hervorhebt, und er verfügt über Autocompletion, welche
 die Eingabe langer Namen abkürzt: Es kann einfach «Enter» gedrückt werden,
 um die Eingabe zu übernehmen.
\end_layout

\begin_layout Standard
Der Editor ist mehrzeilig, und wenn die Interne Simulation verwendet wird
 ist es auch möglich Variable zu definieren (Dies funktioniert nicht mit
 der Matlab Simulation!), und dann später auf diese zurückzugreifen.
 Dies könnte dann in etwa so aussehen:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Mehrzeilige Formel.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Formeleditor
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hierbei werden zuerst die ersten beiden Formel ausgerechnet, danach werden
 diese Zahlen in der dritten Formel eingesetzt und das Resultat der letzten
 Formel wird verwendet.
\end_layout

\begin_layout Standard
Es gibt die Möglichkeit Modelle und Diagramme/XY-Resultate als Bild zu exportier
en.
 Ein entsprechender Button ist entweder im Menü oder in der Toolbar zu finden.
 Es wird dann folgender Dialog angezeigt:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Image export.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Bilderexport
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn gespeichert wird, wird an den Namen automatisch eine fortlaufende Nummer
 angehängt.
 Es können somit mehre Bilder stellt werden mit dem gleichen Namen ohne
 das alte Bild zu überschreiben.
\end_layout

\begin_layout Standard
Die Ordnerauswahl ist Betriebssystem Abhängig, und stellt die Typischen
 Ordner wie Desktop bereit.
 Es kann auch ein Benutzerdefinierter Ordner gewählt werden (unterster Menüeintr
ag).
\end_layout

\begin_layout Standard
Wahl der Bildformate:
\end_layout

\begin_layout Itemize
PNG (Portable Network Graphics): Eine Rastergrafik ohne Qualitätsverluste,
 geeignet für die Darstellung in Webseiten, nicht geeignet für den Druck
\end_layout

\begin_layout Itemize
SVG (Scalable Vector Graphics): Vektorgrafik, geeignet für Darstellungen
 im Web, kann direkt in HTML Seiten eingebunden werden.
\end_layout

\begin_layout Itemize
PS (PostScript): Vektorgrafik.
 Technisch mit PDFs verwandt, geeignet für Druck, meist können Drucker PS
 direkt verarbeiten.
\end_layout

\begin_layout Itemize
EMF (Windows Enhanced Metafile): Dieses Format stammt von Microsoft, und
 findet hauptsächlich in Microsoft Produkten Verwendung.
 Bei älteren Office Versionen ist dies das einzige Vektorgrafikformat das
 unterstützt wird.
\end_layout

\begin_layout Standard
In die Zwischenablage wird immer nur eine Rastergrafik kopiert (Jedes Betriebssy
stem handhabt Vektorgrafiken anders, daher ist der Austausch vom Vektorgrafiken
 nur über Dateien möglich).
\end_layout

\begin_layout Subsection
Erstellen eines XY-Modells
\end_layout

\begin_layout Standard
Das erstellen des XY-Modells erfolgt analog zum erstellen eines Flow-Modellen.
 Es wird hier nur noch beschrieben was spezifisch das XY-Modell betrifft.
\end_layout

\begin_layout Standard
Zusammenhang zwischen den Meso-Kompartimenten und den darunterliegenden
 Flow-Modellen (genannt 
\begin_inset Quotes eld
\end_inset

Sumbodell
\begin_inset Quotes erd
\end_inset

).
 Ganz links in der Toolbar, der graue Kreis, ist das Meso-Kompartiment,
 rechts davon ist der Pfeil für das Drop-Down Menü, welches es ermöglicht
 Submodelle zu erstellen, zu löschen und zu wählen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Bildschirmfoto-10.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Submodell erstellen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Farbe der Sumodelle wird auf dem Farbkreis gleichmässig gewählt, die
 ermöglicht den höchstmöglichen Farbunterschied.
 Theoretisch sind somit bis zu 360 Verschiedene Farben möglich, währen praktisch
 diese natürlich nicht mehr alle unterschieden werden können.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Submodellwahl.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Submodell wählen für neue Meso-Kompartimente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wird ein Sumodell gewählt so nimmt das Meso-Kompartiment in der Toolbar
 die Farbe an, und alle neu erstellten Meso-Kompartimente sind diesem Submodel
 zugeordnet.
 In diesem Menü können auch die Namen der Submodelle geändert werden, und
 es können Submodelle gelöscht werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Submodel Sidebar.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Submodell wählen für bestehende Meso-Kompartimente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wird ein Meso-Kompartiment markiert, so kann das darunterliegende Submodell
 gewählt werden.
 Es können ebenfalls die Gleichungen für die Position X und Y bzw.
 dessen Ableitungen eingegeben werden.
 Hier wäre auch zu erkennen welches Submodell das gewählt ist, falls dies
 Aufgrund zu vieler Farben oder z.B.
 Farbenblindheit nicht möglich ist.
\end_layout

\begin_layout Standard
Wird auf ein Meso-Kompartiment doppelgeklickt, so erscheint das darunterliegende
 Submodell.
 Falls mehrere Meso-Kompartimente dem gleichen Submodell zugeordnet sind
 spielt es keine Rolle auf welches das geklickt wird, es wird immer das
 gleiche Modell angezeigt, und wird dieses editiert betrifft dies auch alle
 
\begin_inset Quotes eld
\end_inset

gleichfarbigen
\begin_inset Quotes erd
\end_inset

 Meso-Kompartimente.
\end_layout

\begin_layout Standard
Unterhalb der «Eigenschaften» Sidebar ist noch die «Dichte Sidebar», hier
 können die Dichten erfasst werden.
 Durch drücken von [+] wird eine neue Dichte erstellt, danach wird auf den
 Schreiber geklickt, um die Dichte zu bearbeiten.
 Wir wählen hier mal 
\begin_inset Quotes eld
\end_inset

sin(x/10)+sin(y/10)
\begin_inset Quotes erd
\end_inset

, dies ergibt ein Karo-Muster.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Dichte.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Submodell wählen für bestehende Meso-Kompartimente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wenn wir nun auf unser Meso-Kompartiment Doppelklicken erscheint das Submodell.
 Neu gibt es nun in der Toolbar auch ein rechteckiger Container, nicht nur
 ein Runder.
 Dieser Container bezieht sich auf eine Dichte des XY-Modells, und ist nur
 im Submodel verfügbar, nicht im Flow-Modell.
 Wir erstellen einen Dichtecontainer.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/handbuch/Dichtecontainer.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Submodell wählen für bestehende Meso-Kompartimente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dieser Dichtecontainer kann in der Sidebar einer Dichte zugeordnet werden.
 Werden nun Ein-/Ausflüsse gemacht, so wird die Dichte verändert, an der
 Position, an der sich das Meso-Kompartiment befindet.
\end_layout

\begin_layout Subsection
Tastenkombinationen
\begin_inset CommandInset label
LatexCommand label
name "sub:Tastenkombinationen"

\end_inset


\end_layout

\begin_layout Standard
Tastenkombinationen werden hier in der Auflistung immer mit CTRL angegeben.
 Auf Mac OS X ist anstelle von CTRL normalerweise COMMAND (
\begin_inset Quotes eld
\end_inset

Blumenkohl
\begin_inset Quotes erd
\end_inset

) zu verwenden.
\end_layout

\begin_layout Subsubsection
Grundlegend
\end_layout

\begin_layout Standard
Dies ist Liste mit den gängigen/nützlichen Tastenkombinationen, die oftmals
 bereits vom Betriebssystem bereitgestellt werden.
 Diese Liste ist nicht vollständig.
 Diese Kombinationen funktionieren an vielen Orten der Applikation, z.B.
 im Hauptfenster, in einzelnen Texteingabefeldern, im Formeleditor etc.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tastenkombination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funktion
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alles markieren
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopieren
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + V
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einfügen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ausschneiden
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Speichern
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + O
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Öffnen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CTRL + N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Neu
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Hauptfenster
\end_layout

\begin_layout Standard
Für die Tastenkombinationen ohne Hilfstaste (CTRL etc.) muss der Fokus auf
 der Zeichnungsfläche liegen.
 Dies geschieht, indem einfach kurz in einen freien Bereich der Zeichnungsfläche
 geklickt wird.
 Die Meisten Tastenkombinationen werden im Menü angegeben, oder in den Tooltips
 der Toolbuttons in Klammern angegeben.
 Diese Liste ist nicht vollständig.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tastenkombination
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funktion
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einfügen eines Parameters (Nur Flow)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einfügen eines Containers (Nur Flow)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einfügen eines Global
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Einfügen eines Textes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
m
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meso-Kompartment (Nur XY)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simulation Starten
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Inhalt der CD
\end_layout

\begin_layout Itemize
/setup: Die Setups für die verschiedenen Betriebssysteme
\end_layout

\begin_deeper
\begin_layout Itemize
/linux
\end_layout

\begin_layout Itemize
/mac
\end_layout

\begin_layout Itemize
/windows
\end_layout

\begin_layout Itemize
/portable
\end_layout

\end_deeper
\begin_layout Itemize
/doku: Die Dokumentation, als Source und PDF
\end_layout

\begin_layout Itemize
/codedoku: Mit Doxygen generierte Sourcecode Dokumentation
\end_layout

\begin_layout Itemize
/src: Der Quellcode der gesamten Applikation, incl.
 Libraries
\end_layout

\end_body
\end_document
